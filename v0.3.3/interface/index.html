<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The AbstractSciMLOperator Interface · SciMLOperators.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/SciMLOperators/stable/interface/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SciMLOperators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SciMLOperators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../sciml/">Usage with <code>SciML</code> and beyond</a></li><li class="is-active"><a class="tocitem" href>The <code>AbstractSciMLOperator</code> Interface</a><ul class="internal"><li><a class="tocitem" href="#Formal-Properties-of-SciMLOperators"><span>Formal Properties of SciMLOperators</span></a></li><li><a class="tocitem" href="#Overloaded-Traits"><span>Overloaded Traits</span></a></li><li><a class="tocitem" href="#Multidimension-arrays-and-batching"><span>Multidimension arrays and batching</span></a></li><li><a class="tocitem" href="#Operator-update"><span>Operator update</span></a></li><li><a class="tocitem" href="#Interface-API-Reference"><span>Interface API Reference</span></a></li><li><a class="tocitem" href="#Traits"><span>Traits</span></a></li><li><a class="tocitem" href="#Note-About-Affine-Operators"><span>Note About Affine Operators</span></a></li><li><a class="tocitem" href="#Note-about-keyword-arguments-to-update_coefficients!"><span>Note about keyword arguments to <code>update_coefficients!</code></span></a></li></ul></li><li><a class="tocitem" href="../premade_operators/">Premade Operators</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/fftw/">FFT Tutorial</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The <code>AbstractSciMLOperator</code> Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The <code>AbstractSciMLOperator</code> Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLOperators.jl/blob/master/docs/src/interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-AbstractSciMLOperator-Interface"><a class="docs-heading-anchor" href="#The-AbstractSciMLOperator-Interface">The <code>AbstractSciMLOperator</code> Interface</a><a id="The-AbstractSciMLOperator-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-AbstractSciMLOperator-Interface" title="Permalink"></a></h1><h2 id="Formal-Properties-of-SciMLOperators"><a class="docs-heading-anchor" href="#Formal-Properties-of-SciMLOperators">Formal Properties of SciMLOperators</a><a id="Formal-Properties-of-SciMLOperators-1"></a><a class="docs-heading-anchor-permalink" href="#Formal-Properties-of-SciMLOperators" title="Permalink"></a></h2><p>These are the formal properties that an <code>AbstractSciMLOperator</code> should obey for it to work in the solvers.</p><ol><li>An <code>AbstractSciMLOperator</code> represents a linear or nonlinear operator with input/output being <code>AbstractArray</code>s. Specifically, a SciMLOperator, <code>L</code>, of size <code>(M, N)</code> accepts input argument <code>u</code> with leading length <code>N</code>, i.e. <code>size(u, 1) == N</code>, and returns an <code>AbstractArray</code> of the same dimension with leading length <code>M</code>, i.e. <code>size(L * u, 1) == M</code>.</li><li>SciMLOperators can be applied to an <code>AbstractArray</code> via overloaded <code>Base.*</code>, or the in-place <code>LinearAlgebra.mul!</code>. Additionally, operators are allowed to be time, or parameter dependent. The state of a SciMLOperator can be updated by calling the mutating function <code>update_coefficients!(L, u, p, t)</code> where <code>p</code> representes parameters, and <code>t</code>, time.  Calling a SciMLOperator as <code>L(du, u, p, t)</code> or out-of-place <code>L(u, p, t)</code> will automatically update the state of <code>L</code> before applying it to <code>u</code>. <code>L(u, p, t)</code> is the same operation as <code>L(u, p, t) * u</code>.</li><li>To support the update functionality, we have lazily implemented a comprehensive operator algebra. That means a user can add, subtract, scale, compose and invert SciMLOperators, and the state of the resultant operator would be updated as expected upon calling <code>L(du, u, p, t)</code> or <code>L(u, p, t)</code> so long as an update function is provided for the component operators.</li></ol><h2 id="Overloaded-Traits"><a class="docs-heading-anchor" href="#Overloaded-Traits">Overloaded Traits</a><a id="Overloaded-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Overloaded-Traits" title="Permalink"></a></h2><p>Thanks to overloads defined for evaluation methods and traits in <code>Base</code>, <code>LinearAlgebra</code>, the behaviour of a <code>SciMLOperator</code> is indistinguishable from an <code>AbstractMatrix</code>. These operators can be passed to linear solver packages, and even to ordinary differential equation solvers. The list of overloads to the <code>AbstractMatrix</code> interface include, but are not limited, the following:</p><ul><li><code>Base: size, zero, one, +, -, *, /, \, ∘, inv, adjoint, transpose, convert</code></li><li><code>LinearAlgebra: mul!, ldiv!, lmul!, rmul!, factorize, issymmetric, ishermitian, isposdef</code></li><li><code>SparseArrays: sparse, issparse</code></li></ul><h2 id="Multidimension-arrays-and-batching"><a class="docs-heading-anchor" href="#Multidimension-arrays-and-batching">Multidimension arrays and batching</a><a id="Multidimension-arrays-and-batching-1"></a><a class="docs-heading-anchor-permalink" href="#Multidimension-arrays-and-batching" title="Permalink"></a></h2><p>SciMLOperator can also be applied to <code>AbstractMatrix</code> subtypes where operator-evaluation is done column-wise.</p><pre><code class="language-julia hljs">K = 10
u_mat = rand(N, K)

v_mat = F(u_mat, p, t) # == mul!(v_mat, F, u_mat)
size(v_mat) == (N, K) # true</code></pre><p><code>L#</code> can also be applied to <code>AbstractArray</code>s that are not <code>AbstractVecOrMat</code>s so long as their size in the first dimension is appropriate for matrix-multiplication. Internally, <code>SciMLOperator</code>s reshapes an <code>N</code>-dimensional array to an <code>AbstractMatrix</code>, and applies the operator via matrix-multiplication.</p><h2 id="Operator-update"><a class="docs-heading-anchor" href="#Operator-update">Operator update</a><a id="Operator-update-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-update" title="Permalink"></a></h2><p>This package can also be used to write time-dependent, and parameter-dependent operators, whose state can be updated per a user-defined function. The updates can be done in-place, i.e. by mutating the object, or out-of-place, i.e. in a non-mutating, <code>Zygote</code>-compatible way.</p><p>For example,</p><pre><code class="language-julia hljs">u = rand(N)
p = rand(N)
t = rand()

# out-of-place update
mat_update_func = (A, u, p, t) -&gt; t * (p * p&#39;)
sca_update_func = (a, u, p, t) -&gt; t * sum(p)

M = MatrixOperator(zero(N, N); update_func = mat_update_func)
α = ScalarOperator(zero(Float64); update_func = sca_update_func)

L = α * M
L = cache_operator(L, u)

# L is initialized with zero state
L * u == zeros(N) # true

# update operator state with `(u, p, t)`
L = update_coefficients(L, u, p, t)
# and multiply
L * u != zeros(N) # true

# updates state and evaluates L at (u, p, t)
L(u, p, t) != zeros(N) # true</code></pre><p>The out-of-place evaluation function <code>L(u, p, t)</code> calls <code>update_coefficients</code> under the hood, which recursively calls the <code>update_func</code> for each component <code>SciMLOperator</code>. Therefore the out-of-place evaluation function is equivalent to calling <code>update_coefficients</code> followed by <code>Base.*</code>. Notice that the out-of-place evaluation does not return the updated operator.</p><p>On the other hand,, the in-place evaluation function, <code>L(v, u, p, t)</code>, mutates <code>L</code>, and is equivalent to calling <code>update_coefficients!</code> followed by <code>mul!</code>. The in-place update behaviour works the same way with a few <code>&lt;!&gt;</code>s appended here and there. For example,</p><pre><code class="language-julia hljs">v = rand(N)
u = rand(N)
p = rand(N)
t = rand()

# in-place update
_A = rand(N, N)
_d = rand(N)
mat_update_func!  = (A, u, p, t) -&gt; (copy!(A, _A); lmul!(t, A); nothing)
diag_update_func! = (diag, u, p, t) -&gt; copy!(diag, N)

M = MatrixOperator(zero(N, N); update_func! = mat_update_func!)
D = DiagonalOperator(zero(N); update_func! = diag_update_func!)

L = D * M
L = cache_operator(L, u)

# L is initialized with zero state
L * u == zeros(N) # true

# update L in-place
update_coefficients!(L, u, p, t)
# and multiply
mul!(v, u, p, t) != zero(N) # true

# updates L in-place, and evaluates at (u, p, t)
L(v, u, p, t) != zero(N) # true</code></pre><p>The update behaviour makes this package flexible enough to be used in <code>OrdianryDiffEq</code>. As the parameter object <code>p</code> is often reserved for sensitivy computation via automatic-differentiation, a user may prefer to pass in state information via other arguments. For that reason, we allow for update functions with arbitrary keyword arguments.</p><pre><code class="language-julia hljs">mat_update_func = (A, u, p, t; scale = 0.0) -&gt; scale * (p * p&#39;)

M = MatrixOperator(zero(N, N); update_func = mat_update_func,
                   accepted_kwargs = (:state,))

M(u, p, t) == zeros(N) # true
M(u, p, t; scale = 1.0) != zero(N)</code></pre><h2 id="Interface-API-Reference"><a class="docs-heading-anchor" href="#Interface-API-Reference">Interface API Reference</a><a id="Interface-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-API-Reference" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.update_coefficients" href="#SciMLOperators.update_coefficients"><code>SciMLOperators.update_coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_coefficients(L, u, p, t; kwargs...)
</code></pre><p>Update the state of <code>L</code> based on <code>u</code>, input vector, <code>p</code> parameter object, <code>t</code>, and keyword arguments. Internally, <code>update_coefficients</code> calls the user-provided <code>update_func</code> method for every component operator in <code>L</code> with the positional arguments <code>(u, p, t)</code> and keyword arguments corresponding to the symbols provided to the operator via kwarg <code>accepted_kwargs</code>.</p><p>This method is out-of-place, i.e. fully non-mutating and <code>Zygote</code>-compatible.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The user-provided <code>update_func[!]</code> must not use <code>u</code> in its computation. Positional argument <code>(u, p, t)</code> to <code>update_func[!]</code> are passed down by <code>update_coefficients[!](L, u, p, t)</code>, where <code>u</code> is the input-vector to the composite <code>AbstractSciMLOperator</code>. For that reason, the values of <code>u</code>, or even shape, may not correspond to the input expected by <code>update_func[!]</code>. If an operator&#39;s state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in <code>FunctionOperator.</code> This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].</p></div></div><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using SciMLOperator

mat_update_func = (A, u, p, t; scale = 1.0) -&gt; p * p&#39; * scale * t

M = MatrixOperator(zeros(4,4); update_func = mat_update_func,
                   accepted_kwargs = (:state,))

L = M + IdentityOperator(4)

u = rand(4)
p = rand(4)
t = 1.0

L = update_coefficients(L, u, p, t; scale = 2.0)
L * u</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.update_coefficients!" href="#SciMLOperators.update_coefficients!"><code>SciMLOperators.update_coefficients!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_coefficients!(L, u, p, t; kwargs...)
</code></pre><p>Update in-place the state of <code>L</code> based on <code>u</code>, input vector, <code>p</code> parameter object, <code>t</code>, and keyword arguments. Internally, <code>update_coefficients!</code> calls the user-provided mutating <code>update_func!</code> method for every component operator in <code>L</code> with the positional arguments <code>(u, p, t)</code> and keyword arguments corresponding to the symbols provided to the operator via kwarg <code>accepted_kwargs</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The user-provided <code>update_func[!]</code> must not use <code>u</code> in its computation. Positional argument <code>(u, p, t)</code> to <code>update_func[!]</code> are passed down by <code>update_coefficients[!](L, u, p, t)</code>, where <code>u</code> is the input-vector to the composite <code>AbstractSciMLOperator</code>. For that reason, the values of <code>u</code>, or even shape, may not correspond to the input expected by <code>update_func[!]</code>. If an operator&#39;s state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in <code>FunctionOperator.</code> This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].</p></div></div><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using SciMLOperator

_A = rand(4, 4)
mat_update_func! = (L, u, p, t; scale = 1.0) -&gt; copy!(A, _A)

M = MatrixOperator(zeros(4,4); update_func! = mat_update_func!)

L = M + IdentityOperator(4)

u = rand(4)
p = rand(4)
t = 1.0

update_coefficients!(L, u, p, t)
L * u</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.cache_operator" href="#SciMLOperators.cache_operator"><code>SciMLOperators.cache_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cache_operator(L, u)
</code></pre><p>Allocate caches for <code>L</code> for in-place evaluation with <code>u</code>-like input vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L159">source</a></section></article><h2 id="Traits"><a class="docs-heading-anchor" href="#Traits">Traits</a><a id="Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Traits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.isconstant" href="#SciMLOperators.isconstant"><code>SciMLOperators.isconstant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isconstant(_)
</code></pre><p>Checks if an <code>L</code>&#39;s state is constant or needs to be updated by calling <code>update_coefficients</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.iscached" href="#SciMLOperators.iscached"><code>SciMLOperators.iscached</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iscached(L)
</code></pre><p>Checks whether <code>L</code> has preallocated caches for inplace evaluations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L128">source</a></section><section><div><p>Check if <code>SciMLOperator</code> <code>L</code> has preallocated cache-arrays for in-place computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L141-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.issquare" href="#SciMLOperators.issquare"><code>SciMLOperators.issquare</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Checks if <code>size(L, 1) == size(L, 2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L318-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.islinear" href="#SciMLOperators.islinear"><code>SciMLOperators.islinear</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">islinear(_)
</code></pre><p>Checks if <code>L</code> is a linear operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.has_adjoint" href="#SciMLOperators.has_adjoint"><code>SciMLOperators.has_adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check if <code>adjoint(L)</code> is lazily defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L189-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.has_expmv" href="#SciMLOperators.has_expmv"><code>SciMLOperators.has_expmv</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check if <code>expmv(L, u, t)</code>, equivalent to <code>exp(t * A) * u</code>, is defined for <code>Number</code> <code>t</code>, and <code>AbstractArray</code> <code>u</code> of appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L198-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.has_expmv!" href="#SciMLOperators.has_expmv!"><code>SciMLOperators.has_expmv!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check if <code>expmv!(v, L, u, t)</code>, equivalent to <code>mul!(v, exp(t * A), u)</code>, is defined for <code>Number</code> <code>t</code>, and <code>AbstractArray</code>s <code>u, v</code> of appropriate sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L193-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.has_exp" href="#SciMLOperators.has_exp"><code>SciMLOperators.has_exp</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check if <code>exp(L)</code> is defined lazily defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L203-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.has_mul" href="#SciMLOperators.has_mul"><code>SciMLOperators.has_mul</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check if <code>L * u</code> is defined for <code>AbstractArray</code> <code>u</code> of appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L207-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.has_mul!" href="#SciMLOperators.has_mul!"><code>SciMLOperators.has_mul!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check if <code>mul!(v, L, u)</code> is defined for <code>AbstractArray</code>s <code>u, v</code> of appropriate sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L211-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.has_ldiv" href="#SciMLOperators.has_ldiv"><code>SciMLOperators.has_ldiv</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check if <code>L \ u</code> is defined for <code>AbstractArray</code> <code>u</code> of appropriate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L216-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators.has_ldiv!" href="#SciMLOperators.has_ldiv!"><code>SciMLOperators.has_ldiv!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Check if <code>ldiv!(v, L, u)</code> is defined for <code>AbstractArray</code>s <code>u, v</code> of appropriate sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/f169b36adf61aaa963226dd536383bd3be90d1b7/src/interface.jl#L220-L223">source</a></section></article><h2 id="Note-About-Affine-Operators"><a class="docs-heading-anchor" href="#Note-About-Affine-Operators">Note About Affine Operators</a><a id="Note-About-Affine-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Note-About-Affine-Operators" title="Permalink"></a></h2><p>Affine operators are operators which have the action <code>Q*x = A*x + b</code>. These operators have no matrix representation, since if there was it would be a linear operator instead of an  affine operator. You can only represent an affine operator as a linear operator in a  dimension of one larger via the operation: <code>[A b] * [u;1]</code>, so it would require something modified  to the input as well. As such, affine operators are a distinct generalization of linear operators.</p><p>While it this seems like it might doom the idea of using matrix-free affine operators, it turns out  that affine operators can be used in all cases where matrix-free linear solvers are used due to an easy genearlization of the standard convergence proofs. If Q is the affine operator  <span>$Q(x) = Ax + b$</span>, then solving <span>$Qx = c$</span> is equivalent to solving <span>$Ax + b = c$</span> or <span>$Ax = c-b$</span>.  If you know do this same &quot;plug-and-chug&quot; handling of the affine operator in into the GMRES/CG/etc.  convergence proofs, move the affine part to the rhs residual, and show it converges to solving  <span>$Ax = c-b$</span>, and thus GMRES/CG/etc. solves <span>$Q(x) = c$</span> for an affine operator properly. </p><p>That same trick then can be used pretty much anywhere you would&#39;ve had a linear operator to extend  the proof to affine operators, so then <span>$exp(A*t)*v$</span> operations via Krylov methods work for A being  affine as well, and all sorts of things. Thus affine operators have no matrix representation but they  are still compatible with essentially any Krylov method which would otherwise be compatible with matrix-free representations, hence their support in the SciMLOperators interface.</p><h2 id="Note-about-keyword-arguments-to-update_coefficients!"><a class="docs-heading-anchor" href="#Note-about-keyword-arguments-to-update_coefficients!">Note about keyword arguments to <code>update_coefficients!</code></a><a id="Note-about-keyword-arguments-to-update_coefficients!-1"></a><a class="docs-heading-anchor-permalink" href="#Note-about-keyword-arguments-to-update_coefficients!" title="Permalink"></a></h2><p>In rare cases, an operator may be used in a context where additional state is expected to be provided to <code>update_coefficients!</code> beyond <code>u</code>, <code>p</code>, and <code>t</code>. In this case, the operator may accept this additional state through arbitrary keyword arguments to <code>update_coefficients!</code>. When the caller provides these, they will be recursively propagated downwards through composed operators just like <code>u</code>, <code>p</code>, and <code>t</code>, and provided to the operator. For the <a href="../premade_operators/">premade SciMLOperators</a>, one can specify the keyword arguments used by an operator with an <code>accepted_kwargs</code> argument (by default, none are passed).</p><p>In the below example, we create an operator that gleefully ignores <code>u</code>, <code>p</code>, and <code>t</code> and uses its own special scaling.</p><pre><code class="language-julia hljs">using SciMLOperators

γ = ScalarOperator(0.0; update_func=(a, u, p, t; my_special_scaling) -&gt; my_special_scaling,
                   accepted_kwargs=(:my_special_scaling,))

# Update coefficients, then apply operator
update_coefficients!(γ, nothing, nothing, nothing; my_special_scaling=7.0)
@show γ * [2.0]

# Use operator application form
@show γ([2.0], nothing, nothing; my_special_scaling = 5.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">γ * [2.0] = [14.0]
γ([2.0], nothing, nothing; my_special_scaling = 5.0) = [10.0]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sciml/">« Usage with <code>SciML</code> and beyond</a><a class="docs-footer-nextpage" href="../premade_operators/">Premade Operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 2 July 2023 20:26">Sunday 2 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
