<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The AbstractSciMLOperator Interface · SciMLOperators.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://scimlbase.sciml.ai/stable/interface/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SciMLOperators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SciMLOperators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>The AbstractSciMLOperator Interface</a><ul class="internal"><li><a class="tocitem" href="#Formal-Properties-of-SciMLOperators"><span>Formal Properties of SciMLOperators</span></a></li><li><a class="tocitem" href="#AbstractSciMLOperator-Interface-Description"><span>AbstractSciMLOperator Interface Description</span></a></li><li><a class="tocitem" href="#Note-About-Affine-Operators"><span>Note About Affine Operators</span></a></li></ul></li><li><a class="tocitem" href="../premade_operators/">Premade SciMLOperators</a></li><li><a class="tocitem" href="../tutorials/fftw/">Wrap a Fourier transform with SciMLOperators</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The AbstractSciMLOperator Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The AbstractSciMLOperator Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLOperators.jl/blob/master/docs/src/interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-AbstractSciMLOperator-Interface"><a class="docs-heading-anchor" href="#The-AbstractSciMLOperator-Interface">The AbstractSciMLOperator Interface</a><a id="The-AbstractSciMLOperator-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#The-AbstractSciMLOperator-Interface" title="Permalink"></a></h1><h2 id="Formal-Properties-of-SciMLOperators"><a class="docs-heading-anchor" href="#Formal-Properties-of-SciMLOperators">Formal Properties of SciMLOperators</a><a id="Formal-Properties-of-SciMLOperators-1"></a><a class="docs-heading-anchor-permalink" href="#Formal-Properties-of-SciMLOperators" title="Permalink"></a></h2><p>These are the formal properties that an <code>AbstractSciMLOperator</code> should obey for it to work in the solvers.</p><ol><li>An <code>AbstractSciMLOperator</code> represents a linear or nonlinear operator with input/output being <code>AbstractArray</code>s. Specifically, a SciMLOperator, <code>L</code>, of size <code>(M,N)</code> accepts input argument <code>u</code> with leading length <code>N</code>, i.e. <code>size(u, 1) == N</code>, and returns an <code>AbstractArray</code> of the same dimension with leading length <code>M</code>, i.e. <code>size(L * u, 1) == M</code>.</li><li>SciMLOperators can be applied to an <code>AbstractArray</code> via overloaded <code>Base.*</code>, or the in-place <code>LinearAlgebra.mul!</code>. Additionally, operators are allowed to be time, or parameter dependent. The state of a SciMLOperator can be updated by calling the mutating function <code>update_coefficients!(L, u, p, t)</code> where <code>p</code> representes parameters, and <code>t</code>, time.  Calling a SciMLOperator as <code>L(du, u, p, t)</code> or out-of-place <code>L(u, p, t)</code> will automatically update the state of <code>L</code> before applying it to <code>u</code>. <code>L(u, p, t)</code> is the same operation as <code>L(u, p, t) * u</code>.</li><li>To support the update functionality, we have lazily implemented a comprehensive operator algebra. That means a user can add, subtract, scale, compose and invert SciMLOperators, and the state of the resultant operator would be updated as expected upon calling <code>L(du, u, p, t)</code> or <code>L(u, p, t)</code> so long as an update function is provided for the component operators.</li></ol><h2 id="AbstractSciMLOperator-Interface-Description"><a class="docs-heading-anchor" href="#AbstractSciMLOperator-Interface-Description">AbstractSciMLOperator Interface Description</a><a id="AbstractSciMLOperator-Interface-Description-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractSciMLOperator-Interface-Description" title="Permalink"></a></h2><ol><li><code>AbstractSciMLLinearOperator &lt;: AbstractSciMLOperator</code></li><li><code>AbstractSciMLScalarOperator &lt;: AbstractSciMLLinearOperator</code></li><li><code>isconstant(A)</code> trait for whether the operator is constant or not.</li><li>Optional: <code>exp(A)</code>. Required for simple exponential integration.</li><li>Optional: <code>expv(A,u,t) = exp(t*A)*u</code> and <code>expv!(v,A::AbstractSciMLOperator,u,t)</code> Required for sparse-saving exponential integration.</li><li>Optional: factorizations. <code>ldiv!</code>, <code>factorize</code> et. al. This is only required for algorithms which use the factorization of the operator (Crank-Nicolson), and only for when the default linear solve is used.</li></ol><h2 id="Note-About-Affine-Operators"><a class="docs-heading-anchor" href="#Note-About-Affine-Operators">Note About Affine Operators</a><a id="Note-About-Affine-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Note-About-Affine-Operators" title="Permalink"></a></h2><p>Affine operators are operators which have the action <code>Q*x = A*x + b</code>. These operators have no matrix representation, since if there was it would be a linear operator instead of an  affine operator. You can only represent an affine operator as a linear operator in a  dimension of one larger via the operation: <code>[A b] * [u;1]</code>, so it would require something modified  to the input as well. As such, affine operators are a distinct generalization of linear operators.</p><p>While it this seems like it might doom the idea of using matrix-free affine operators, it turns out  that affine operators can be used in all cases where matrix-free linear solvers are used due to an easy genearlization of the standard convergence proofs. If Q is the affine operator  <span>$Q(x) = Ax + b$</span>, then solving <span>$Qx = c$</span> is equivalent to solving <span>$Ax + b = c$</span> or <span>$Ax = c-b$</span>.  If you know do this same &quot;plug-and-chug&quot; handling of the affine operator in into the GMRES/CG/etc.  convergence proofs, move the affine part to the rhs residual, and show it converges to solving  <span>$Ax = c-b$</span>, and thus GMRES/CG/etc. solves <span>$Q(x) = c$</span> for an affine operator properly. </p><p>That same trick then can be used pretty much anywhere you would&#39;ve had a linear operator to extend  the proof to affine operators, so then <span>$exp(A*t)*v$</span> operations via Krylov methods work for A being  affine as well, and all sorts of things. Thus affine operators have no matrix representation but they  are still compatible with essentially any Krylov method which would otherwise be compatible with matrix-free representations, hence their support in the SciMLOperators interface.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../premade_operators/">Premade SciMLOperators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 24 September 2022 19:43">Saturday 24 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
