<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SciMLOperators.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/SciMLOperators/stable/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="SciMLOperators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>SciMLOperators.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Reproducibility"><span>Reproducibility</span></a></li></ul></li><li><a class="tocitem" href="interface/">Interface</a></li><li><a class="tocitem" href="premade_operators/">Premade Operators</a></li><li><a class="tocitem" href="api/">API</a></li><li><a class="tocitem" href="tutorials/fftw/">FFT Tutorial</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLOperators.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SciMLOperators.jl:-The-SciML-Operators-Interface"><a class="docs-heading-anchor" href="#SciMLOperators.jl:-The-SciML-Operators-Interface">SciMLOperators.jl: The SciML Operators Interface</a><a id="SciMLOperators.jl:-The-SciML-Operators-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#SciMLOperators.jl:-The-SciML-Operators-Interface" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SciMLOperators" href="#SciMLOperators"><code>SciMLOperators</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong><code>SciMLOperators.jl</code></strong></p><p><em>Unified operator interface for <code>SciML.ai</code> and beyond</em></p><p><a href="https://julialang.zulipchat.com/#narrow/stream/279055-sciml-bridged"><img src="https://img.shields.io/static/v1?label=Zulip&amp;message=chat&amp;color=9558b2&amp;labelColor=389826" alt="Join the chat at https://julialang.zulipchat.com #sciml-bridged"/></a> <a href="https://docs.sciml.ai/SciMLOperators/stable"><img src="https://img.shields.io/badge/docs-SciML-blue.svg" alt="Global Docs"/></a></p><p><a href="https://codecov.io/gh/SciML/SciMLOperators.jl"><img src="https://codecov.io/gh/SciML/SciMLOperators.jl/branch/master/graph/badge.svg" alt="codecov"/></a> <a href="https://github.com/SciML/SciMLOperators.jl/actions?query=workflow%3ACI"><img src="https://github.com/SciML/SciMLOperators.jl/workflows/CI/badge.svg" alt="Build Status"/></a></p><p><a href="https://github.com/SciML/ColPrac"><img src="https://img.shields.io/badge/ColPrac-Contributor&#39;s%20Guide-blueviolet" alt="ColPrac: Contributor&#39;s Guide on Collaborative Practices for Community Packages"/></a> <a href="https://github.com/SciML/SciMLStyle"><img src="https://img.shields.io/static/v1?label=code%20style&amp;message=SciML&amp;color=9558b2&amp;labelColor=389826" alt="SciML Code Style"/></a></p><p><code>SciMLOperators</code> is a package for managing linear, nonlinear, time-dependent, and parameter dependent operators acting on vectors, (or column-vectors of matrices). We provide wrappers for matrix-free operators, fast tensor-product evaluations, pre-cached mutating evaluations, as well as <code>Zygote</code>-compatible non-mutating evaluations.</p><p>The lazily implemented operator algebra allows the user to update the operator state by passing in an update function that accepts arbirary parameter objects. Further, our operators behave like <code>AbstractMatrix</code> types thanks to  overloads defined for methods in <code>Base</code>, and <code>LinearAlgebra</code>.</p><p>Therefore, an <code>AbstractSciMLOperator</code> can be passed to <code>LinearSolve.jl</code>, or <code>NonlinearSolve.jl</code> as a linear/nonlinear operator, or to <code>OrdinaryDiffEq.jl</code> as an <code>ODEFunction</code>. Examples of usage within the <code>SciML</code> ecosystem are provided in the documentation.</p><p><strong>Installation</strong></p><p><code>SciMLOperators.jl</code> is a registerd package and can be installed via</p><pre><code class="nohighlight hljs">julia&gt; import Pkg
julia&gt; Pkg.add(&quot;SciMLOperators&quot;)</code></pre><p><strong>Examples</strong></p><p>Let <code>M</code>, <code>D</code>, <code>F</code> be matrix, diagonal matrix, and function-based <code>SciMLOperators</code> respectively.</p><pre><code class="language-julia hljs">N = 4
f = (u, p, t) -&gt; u .* u

M = MatrixOperator(rand(N, N))
D = DiagonalOperator(rand(N))
F = FunctionOperator(f, zeros(N), zeros(N))</code></pre><p>Then, the following codes just work.</p><pre><code class="language-julia hljs">L1 = 2M + 3F + LinearAlgebra.I + rand(N, N)
L2 = D * F * M&#39;
L3 = kron(M, D, F)
L4 = M \ D
L5 = [M; D]&#39; * [M F; F D] * [F; D]</code></pre><p>Each <code>L#</code> can be applied to <code>AbstractVector</code>s of appropriate sizes:</p><pre><code class="language-julia hljs">p = nothing # parameter struct
t = 0.0     # time

u = rand(N)
v = L1(u, p, t) # == L1 * u

u_kron = rand(N ^ 3)
v_kron = L3(u_kron, p, t) # == L3 * u_kron</code></pre><p>For mutating operator evaluations, call <code>cache_operator</code> to generate in-place cache so the operation is nonallocating.</p><pre><code class="language-julia hljs">α, β = rand(2)

# allocate cache
L2 = cache_operator(L2, u)
L4 = cache_operator(L4, u)

# allocation-free evaluation
L2(v, u, p, t) # == mul!(v, L2, u)
L4(v, u, p, t, α, β) # == mul!(v, L4, u, α, β)</code></pre><p>The calling signature <code>L(u, p, t)</code>, for out-of-place evaluations is equivalent to <code>L * u</code>, and the in-place evaluation <code>L(v, u, p, t, args...)</code> is equivalent to <code>LinearAlgebra.mul!(v, L, u, args...)</code>, where the arguments <code>p, t</code> are passed to <code>L</code> to update its state. More details are provided in the operator update section below. While overloads to <code>Base.*</code> and <code>LinearAlgebra.mul!</code> are available, where a <code>SciMLOperator</code> behaves like an <code>AbstractMatrix</code>, we recommend sticking with the <code>L(u, p, t)</code>, <code>L(v, u, p, t)</code>, <code>L(v, u, p, t, α, β)</code> calling signatures as the latter internally update the operator state.</p><p>The <code>(u, p, t)</code> calling signature is standardized over the <code>SciML</code> ecosystem and is flexible enough to support use cases such as time-evolution in ODEs, as well as sensitivity computation with respect to the parameter object <code>p</code>.</p><p>Thanks to overloads defined for evaluation methods and traits in <code>Base</code>, <code>LinearAlgebra</code>, the behaviour of a <code>SciMLOperator</code> is indistinguishable from an <code>AbstractMatrix</code>. These operators can be passed to linear solver packages, and even to ordinary differential equation solvers. The list of overloads to the <code>AbstractMatrix</code> interface include, but are not limited, the following:</p><ul><li><code>Base: size, zero, one, +, -, *, /, \, ∘, inv, adjoint, transpose, convert</code></li><li><code>LinearAlgebra: mul!, ldiv!, lmul!, rmul!, factorize, issymmetric, ishermitian, isposdef</code></li><li><code>SparseArrays: sparse, issparse</code></li></ul><p><strong>Multidimension arrays and batching</strong></p><p>SciMLOperator can also be applied to <code>AbstractMatrix</code> subtypes where operator-evaluation is done column-wise.</p><pre><code class="language-julia hljs">K = 10
u_mat = rand(N, K)

v_mat = F(u_mat, p, t) # == mul!(v_mat, F, u_mat)
size(v_mat) == (N, K) # true</code></pre><p><code>L#</code> can also be applied to <code>AbstractArray</code>s that are not <code>AbstractVecOrMat</code>s so long as their size in the first dimension is appropriate for matrix-multiplication. Internally, <code>SciMLOperator</code>s reshapes an <code>N</code>-dimensional array to an <code>AbstractMatrix</code>, and applies the operator via matrix-multiplication.</p><p><strong>Operator update</strong></p><p>This package can also be used to write time-dependent, and parameter-dependent operators, whose state can be updated per a user-defined function. The updates can be done in-place, i.e. by mutating the object, or out-of-place, i.e. in a non-mutating, <code>Zygote</code>-compatible way.</p><p>For example,</p><pre><code class="language-julia hljs">u = rand(N)
p = rand(N)
t = rand()

# out-of-place update
mat_update_func = (A, u, p, t) -&gt; t * (p * p&#39;)
sca_update_func = (a, u, p, t) -&gt; t * sum(p)

M = MatrixOperator(zero(N, N); update_func = mat_update_func)
α = ScalarOperator(zero(Float64); update_func = sca_update_func)

L = α * M
L = cache_operator(L, u)

# L is initialized with zero state
L * u == zeros(N) # true

# update operator state with `(u, p, t)`
L = update_coefficients(L, u, p, t)
# and multiply
L * u != zeros(N) # true

# updates state and evaluates L at (u, p, t)
L(u, p, t) != zeros(N) # true</code></pre><p>The out-of-place evaluation function <code>L(u, p, t)</code> calls <code>update_coefficients</code> under the hood, which recursively calls the <code>update_func</code> for each component <code>SciMLOperator</code>. Therefore the out-of-place evaluation function is equivalent to calling <code>update_coefficients</code> followed by <code>Base.*</code>. Notice that the out-of-place evaluation does not return the updated operator.</p><p>On the other hand,, the in-place evaluation function, <code>L(v, u, p, t)</code>, mutates <code>L</code>, and is equivalent to calling <code>update_coefficients!</code> followed by <code>mul!</code>. The in-place update behaviour works the same way with a few <code>&lt;!&gt;</code>s appended here and there. For example,</p><pre><code class="language-julia hljs">v = rand(N)
u = rand(N)
p = rand(N)
t = rand()

# in-place update
_A = rand(N, N)
_d = rand(N)
mat_update_func!  = (A, u, p, t) -&gt; (copy!(A, _A); lmul!(t, A); nothing)
diag_update_func! = (diag, u, p, t) -&gt; copy!(diag, N)

M = MatrixOperator(zero(N, N); update_func! = mat_update_func!)
D = DiagonalOperator(zero(N); update_func! = diag_update_func!)

L = D * M
L = cache_operator(L, u)

# L is initialized with zero state
L * u == zeros(N) # true

# update L in-place
update_coefficients!(L, u, p, t)
# and multiply
mul!(v, u, p, t) != zero(N) # true

# updates L in-place, and evaluates at (u, p, t)
L(v, u, p, t) != zero(N) # true</code></pre><p>The update behaviour makes this package flexible enough to be used in <code>OrdianryDiffEq</code>. As the parameter object <code>p</code> is often reserved for sensitivy computation via automatic-differentiation, a user may prefer to pass in state information via other arguments. For that reason, we allow for update functions with arbitrary keyword arguments.</p><pre><code class="language-julia hljs">mat_update_func = (A, u, p, t; scale = 0.0) -&gt; scale * (p * p&#39;)

M = MatrixOperator(zero(N, N); update_func = mat_update_func,
                   accepted_kwargs = (:state,))

M(u, p, t) == zeros(N) # true
M(u, p, t; scale = 1.0) != zero(N)</code></pre><p><strong>Features</strong></p><ul><li>Matrix-free operators with <code>FunctionOperator</code></li><li>Fast tensor product evaluation</li><li>Mutating, nonmutating update behaviour (Zygote compatible)</li><li><code>InvertibleOperator</code> - pair fwd, bwd operators</li><li>Lazy algebra: addition, subtraction, multiplication, inverse, adjoint</li><li>Pre-caching methods for in-place evaluations</li></ul><p><strong>Why <code>SciMLOperators</code>?</strong></p><p>Many functions, from linear solvers to differential equations, require the use of matrix-free operators in order to achieve maximum performance in many scenarios. <code>SciMLOperators.jl</code> defines the abstract interface for how operators in the SciML ecosystem are supposed to be defined. It gives the common set of functions and traits which solvers can rely on for properly performing their tasks. Along with that, <code>SciMLOperators.jl</code> provides definitions for the basic standard operators which are used in building blocks for most tasks, both simplifying the use of operators while also demonstrating to users how such operators can be built and used in practice.</p><p><code>SciMLOperators.jl</code> has the design that is required in order to be used in all scenarios of equation solvers. For example, Magnus integrators for differential equations require defining an operator <span>$u&#39; = A(t) u$</span>, while Munthe-Kaas methods require defining operators of the form <span>$u&#39; = A(u) u$</span>. Thus the operators need some form of time and state dependence which the solvers can update and query when they are non-constant (<code>update_coefficients!</code>). Additionally, the operators need the ability to act like &quot;normal&quot; functions for equation solvers. For example, if <code>A(u,p,t)</code> has the same operation as <code>update_coefficients(A, u, p, t); A * u</code>, then <code>A</code> can be used in any place where a differential equation definition <code>f(u, p, t)</code> is used without requring the user or solver to do any extra work. Thus while previous good efforts for matrix-free operators have existed in the Julia ecosystem, such as <a href="https://github.com/JuliaLinearAlgebra/LinearMaps.jl">LinearMaps.jl</a>, those operator interfaces lack these aspects in order to actually be fully seamless with downstream equation solvers. This necessitates the definition and use of an extended operator interface with all of these properties, hence the <code>AbstractSciMLOperator</code> interface.</p><p>Some packages providing similar functionality are</p><ul><li><a href="https://github.com/JuliaLinearAlgebra/LinearMaps.jl">LinearMaps.jl</a></li><li><a href="https://github.com/SciML/DiffEqOperators.jl/tree/master"><code>DiffEqOperators.jl</code></a> (deprecated)</li></ul><p><strong>Interoperability and extended Julia ecosystem</strong></p><p><code>SciMLOperator.jl</code> overloads the <code>AbstractMatrix</code> interface for <code>AbstractSciMLOperator</code>s, allowing seamless compatibility with linear solves, and nonlinear solvers. Further, due to the update functionality, <code>AbstractSciMLOperator</code>s can represent an <code>ODEFunction</code> in <code>OrdinaryDiffEq.jl</code>, and downstream packages. See tutorials for example of usage with <code>OrdinaryDiffEq.jl</code>, <code>LinearSolve.jl</code>, <code>NonlinearSolve.jl</code>.</p><p>Further, the nonmutating update functionality allows gradient propogation through <code>AbstractSciMLOperator</code>s, and is compatible with automatic-differentiation libraries like <a href="https://github.com/SciML/DiffEqOperators.jl/tree/master"><code>Zygote.jl</code></a>. An example of <code>Zygote.jl</code> usage with <a href="https://github.com/LuxDL/Lux.jl"><code>Lux.jl</code></a> is also provided in the tutorials.</p><p>Please make an issue <a href="https://github.com/SciML/SciMLOperators.jl/issues">here</a> if you come across an unexpected issue while using <code>SciMLOperators</code>.</p><p>We provide below a list of packages that make use of <code>SciMLOperators</code>. If you are using <code>SciMLOperators</code> in your work, feel free to create a PR and add your package to this list.</p><ul><li><a href="https://sciml.ai/"><code>SciML.ai</code></a> ecosystem: <code>SciMLOperators</code> is compatible with, and utilized by every <code>SciML</code> package.</li><li><a href="https://github.com/CalculustJL"><code>CalculustJL</code></a> packages use <code>SciMLOperators</code> to define matrix-free vector-calculus operators for solving partial differential equations.<ul><li><a href="https://github.com/CalculustJL/CalculustCore.jl"><code>CalculustCore.jl</code></a></li><li><a href="https://github.com/CalculustJL/FourierSpaces.jl"><code>FourierSpaces.jl</code></a></li><li><a href="https://github.com/CalculustJL/NodalPolynomialSpaces.jl"><code>NodalPolynomialSpaces.jl</code></a></li></ul></li><li><code>SparseDiffTools.jl</code></li></ul><p><strong>Roadmap</strong></p><ul><li>[ ] <a href="https://github.com/SciML/SciMLOperators.jl/issues/142">Complete integration with <code>SciML</code> ecosystem</a></li><li>[ ] <a href="https://github.com/SciML/SciMLOperators.jl/issues/161">Block-matrices</a></li><li>[x] <a href="https://github.com/SciML/SciMLOperators.jl/issues/58">Benchmark and speed-up tensorbproduct evaluations</a></li><li>[ ] <a href="https://github.com/SciML/SciMLOperators.jl/issues/53">Fast tensor-sum (<code>kronsum</code>) evaluation</a></li><li>[ ] <a href="https://github.com/SciML/SciMLOperators.jl/issues/62">Fully flesh out operator array algebra</a></li><li>[ ] <a href="https://github.com/SciML/SciMLOperators.jl/issues/51">Operator fusion/matrix chain multiplication at constant <code>(u, p, t)</code>-slices</a></li></ul><p><strong>Contributing</strong></p><ul><li>Please refer to the <a href="https://github.com/SciML/ColPrac/blob/master/README.md">SciML ColPrac: Contributor&#39;s Guide on Collaborative Practices for Community Packages</a> for guidance on PRs, issues, and other matters relating to contributing to SciML.</li><li>There are a few community forums:<ul><li>The #diffeq-bridged and #sciml-bridged channels in the <a href="https://julialang.org/slack/">Julia Slack</a></li><li><a href="https://gitter.im/JuliaDiffEq/Lobby">JuliaDiffEq</a> on Gitter</li><li>On the Julia Discourse forums (look for the <a href="https://discourse.julialang.org/tag/modelingtoolkit">modelingtoolkit tag</a></li><li>See also <a href="https://sciml.ai/community/">SciML Community page</a></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/SciMLOperators.jl/blob/2eaf24006f9d848688e1c550460d4478c9af67ea/src/SciMLOperators.jl#L1">source</a></section></article><h2 id="Reproducibility"><a class="docs-heading-anchor" href="#Reproducibility">Reproducibility</a><a id="Reproducibility-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducibility" title="Permalink"></a></h2><details><summary>The documentation of this SciML package was built using these direct dependencies,</summary><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Status `~/work/SciMLOperators.jl/SciMLOperators.jl/docs/Project.toml`
  [e30172f5] Documenter v0.27.24
  [c0aeaf25] SciMLOperators v0.2.11 `~/work/SciMLOperators.jl/SciMLOperators.jl`</code></pre></details><details><summary>and using this machine and Julia version.</summary><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.9.0
Commit 8e630552924 (2023-05-07 11:25 UTC)
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: 2 × Intel(R) Xeon(R) Platinum 8370C CPU @ 2.80GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-14.0.6 (ORCJIT, icelake-server)
  Threads: 1 on 2 virtual cores</code></pre></details><details><summary>A more complete overview of all dependencies and their versions is also provided.</summary><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Status `~/work/SciMLOperators.jl/SciMLOperators.jl/docs/Manifest.toml`
  [a4c015fc] ANSIColoredPrinters v0.0.1
  [79e6a3ab] Adapt v3.6.2
  [4fba245c] ArrayInterface v7.4.8
  [187b0558] ConstructionBase v1.5.2
  [ffbed154] DocStringExtensions v0.9.3
  [e30172f5] Documenter v0.27.24
  [b5f81e59] IOCapture v0.2.3
  [682c06a0] JSON v0.21.4
  [50d2b5c4] Lazy v0.15.1
  [1914dd2f] MacroTools v0.5.10
  [69de0a69] Parsers v2.5.10
  [aea7be01] PrecompileTools v1.1.2
  [21216c6a] Preferences v1.4.0
  [ae029012] Requires v1.3.0
  [c0aeaf25] SciMLOperators v0.2.11 `~/work/SciMLOperators.jl/SciMLOperators.jl`
  [efcf1570] Setfield v1.1.1
  [1e83bf80] StaticArraysCore v1.4.0
  [410a4b4d] Tricks v0.1.7
  [0dad84c5] ArgTools v1.1.1
  [56f22d72] Artifacts
  [2a0f44e3] Base64
  [ade2ca70] Dates
  [f43a241f] Downloads v1.6.0
  [7b1f6079] FileWatching
  [9fa8497b] Future
  [b77e0a4c] InteractiveUtils
  [b27032c2] LibCURL v0.6.3
  [76f85450] LibGit2
  [8f399da3] Libdl
  [37e2e46d] LinearAlgebra
  [56ddb016] Logging
  [d6f4376e] Markdown
  [a63ad114] Mmap
  [ca575930] NetworkOptions v1.2.0
  [44cfe95a] Pkg v1.9.0
  [de0858da] Printf
  [3fa0cd96] REPL
  [9a3f8284] Random
  [ea8e919c] SHA v0.7.0
  [9e88b42a] Serialization
  [6462fe0b] Sockets
  [2f01184e] SparseArrays
  [4607b0f0] SuiteSparse
  [fa267f1f] TOML v1.0.3
  [a4e569a6] Tar v1.10.0
  [8dfed614] Test
  [cf7118a7] UUIDs
  [4ec0a83e] Unicode
  [e66e0078] CompilerSupportLibraries_jll v1.0.2+0
  [deac9b47] LibCURL_jll v7.84.0+0
  [29816b5a] LibSSH2_jll v1.10.2+0
  [c8ffd9c3] MbedTLS_jll v2.28.2+0
  [14a3606d] MozillaCACerts_jll v2022.10.11
  [4536629a] OpenBLAS_jll v0.3.21+4
  [bea87d4a] SuiteSparse_jll v5.10.1+6
  [83775a58] Zlib_jll v1.2.13+0
  [8e850b90] libblastrampoline_jll v5.7.0+0
  [8e850ede] nghttp2_jll v1.48.0+0
  [3f19e933] p7zip_jll v17.4.0+0</code></pre></details>You can also download the 
<a href="https://github.com/SciML/SciMLOperators.jl/tree/gh-pages/v0.2.11/assets/Manifest.toml">manifest</a> file and the
<a href="https://github.com/SciML/SciMLOperators.jl/tree/gh-pages/v0.2.11/assets/Project.toml">project</a> file.</article><nav class="docs-footer"><a class="docs-footer-nextpage" href="interface/">Interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 5 June 2023 02:28">Monday 5 June 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
