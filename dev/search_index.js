var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Modules = [SciMLOperators]\nOrder = [:function, :type]","category":"page"},{"location":"api/#SciMLOperators.AddVector-Tuple{AbstractVecOrMat}","page":"API","title":"SciMLOperators.AddVector","text":"L = AddVector(b; [update_func, update_func!, accepted_kwargs])\nL(u) = u + b\n\n\n\n\n\n","category":"method"},{"location":"api/#SciMLOperators.AddVector-Tuple{Any, AbstractVecOrMat}","page":"API","title":"SciMLOperators.AddVector","text":"L = AddVector(B, b; [update_func, accepted_kwargs])\nL(u) = u + B*b\n\n\n\n\n\n","category":"method"},{"location":"api/#SciMLOperators.DEFAULT_UPDATE_FUNC-NTuple{4, Any}","page":"API","title":"SciMLOperators.DEFAULT_UPDATE_FUNC","text":"DEFAULT_UPDATE_FUNC(A, u, p, t)\n\n\nThe default update function for AbstractSciMLOperators, a no-op that leaves the operator state unchanged.\n\n\n\n\n\n","category":"method"},{"location":"api/#SciMLOperators.DiagonalOperator-Tuple{AbstractVector}","page":"API","title":"SciMLOperators.DiagonalOperator","text":"DiagonalOperator(\n    diag;\n    update_func,\n    update_func!,\n    accepted_kwargs\n)\n\n\nRepresents a elementwise scaling (diagonal-scaling) operation that may be applied to an AbstractVecOrMat. When diag is an AbstractVector of length N, L = DiagonalOpeator(diag, ...) can be applied to AbstractArrays with size(u, 1) == N. Each column of the u will be scaled by diag, as in LinearAlgebra.Diagonal(diag) * u.\n\nWhen diag is a multidimensional array, L = DiagonalOperator(diag, ...) forms an operator of size (N, N) where N = size(diag, 1) is the leading length of diag. L then is the elementwise-scaling operation on arrays of length(u) = length(diag) with leading length size(u, 1) = N.\n\nIts state is updated by the user-provided update_func during operator evaluation (L([v,], u, p, t)), or by calls to update_coefficients[!](L, u, p, t). Both recursively call the update_function, update_func which is assumed to have the signature\n\nupdate_func(diag::AbstractVecOrMat, u, p, t; <accepted kwargs>) -> new_diag\n\nor     update_func!(diag::AbstractVecOrMat, u, p, t; <accepted kwargs>) -> [modifies diag]\n\nThe set of keyword-arguments accepted by update_func[!] must be provided to MatrixOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func[!] if accepted_kwargs are not provided.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"api/#SciMLOperators.cache_operator","page":"API","title":"SciMLOperators.cache_operator","text":"Allocate caches for L for in-place evaluation with u-like input vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/#SciMLOperators.iscached-Tuple{SciMLOperators.AbstractSciMLOperator}","page":"API","title":"SciMLOperators.iscached","text":"iscached(L)\n\n\nChecks whether L has preallocated caches for inplace evaluations.\n\n\n\n\n\n","category":"method"},{"location":"api/#SciMLOperators.isconstant-Tuple{Union{Number, LinearAlgebra.Factorization, LinearAlgebra.UniformScaling, AbstractMatrix}}","page":"API","title":"SciMLOperators.isconstant","text":"isconstant(_)\n\n\nChecks if an operator's state is constant or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#SciMLOperators.islinear-Tuple{SciMLOperators.AbstractSciMLOperator}","page":"API","title":"SciMLOperators.islinear","text":"islinear(_)\n\n\nChecks whether operator is linear or not.\n\n\n\n\n\n","category":"method"},{"location":"api/#SciMLOperators.update_coefficients","page":"API","title":"SciMLOperators.update_coefficients","text":"Update the state of L based on u, input vector, p parameter object, t, and keyword arguments. Internally, update_coefficients calls the user-provided update_func method for every component operator in L with the positional arguments (u, p, t) and keyword arguments corresponding to the symbols provided to the operator via kwarg accepted_kwargs.\n\nThis method is out-of-place, i.e. fully non-mutating and Zygote-compatible.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nExample\n\nusing SciMLOperator\n\nmat_update_func = (A, u, p, t; scale = 1.0) -> p * p' * scale * t\n\nM = MatrixOperator(zeros(4,4); update_func = mat_update_func,\n                   accepted_kwargs = (:state,))\n\nL = M + IdentityOperator(4)\n\nu = rand(4)\np = rand(4)\nt = 1.0\n\nL = update_coefficients(L, u, p, t; scale = 2.0)\nL * u\n\n\n\n\n\n","category":"function"},{"location":"api/#SciMLOperators.update_coefficients!","page":"API","title":"SciMLOperators.update_coefficients!","text":"Update in-place the state of L based on u, input vector, p parameter object, t, and keyword arguments. Internally, update_coefficients! calls the user-provided mutating update_func! method for every component operator in L with the positional arguments (u, p, t) and keyword arguments corresponding to the symbols provided to the operator via kwarg accepted_kwargs.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nExample\n\nusing SciMLOperator\n\n_A = rand(4, 4)\nmat_update_func! = (L, u, p, t; scale = 1.0) -> copy!(A, _A)\n\nM = MatrixOperator(zeros(4,4); update_func! = mat_update_func!)\n\nL = M + IdentityOperator(4)\n\nu = rand(4)\np = rand(4)\nt = 1.0\n\nupdate_coefficients!(L, u, p, t)\nL * u\n\n\n\n\n\n","category":"function"},{"location":"api/#SciMLOperators.AbstractSciMLOperator","page":"API","title":"SciMLOperators.AbstractSciMLOperator","text":"abstract type AbstractSciMLOperator{T}\n\nSubtypes of AbstractSciMLOperator represent linear, nonlinear, time-dependent operators acting on vectors, or matrix column-vectors. A lazy operator algebra is also defined for AbstractSciMLOperators.\n\nInterface\n\nAn AbstractSciMLOperator can be called like a function. This behaves like multiplication by the linear operator represented by the AbstractSciMLOperator. Possible signatures are\n\nL(du, u, p, t) for in-place operator evaluation\ndu = L(u, p, t) for out-of-place operator evaluation\n\nOperator evaluation methods update its coefficients with (u, p, t) information using the update_coefficients(!) method. The methods are exported and can be called as follows:\n\nupdate_coefficients!(L, u, p, t) for out-of-place operator update\nL = update_coefficients(L, u, p, t) for in-place operator update\n\nSciMLOperators also overloads Base.*, LinearAlgebra.mul!, LinearAlgebra.ldiv! for operator evaluation without updating operator state. An AbstractSciMLOperator behaves like a matrix in these methods. Allocation-free methods, suffixed with a ! often need cache arrays. To precache an AbstractSciMLOperator, call the function L = cache_operator(L, input_vector).\n\nMethods\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.AbstractSciMLScalarOperator","page":"API","title":"SciMLOperators.AbstractSciMLScalarOperator","text":"abstract type AbstractSciMLScalarOperator{T} <: SciMLOperators.AbstractSciMLOperator{T}\n\nAn AbstractSciMLScalarOperator represents a linear scaling operation that may be applied to Number, AbstractVecOrMat subtypes. Addition, multiplication, division of AbstractSciMLScalarOperators is defined lazily so operator state may be updated.\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.AddedOperator","page":"API","title":"SciMLOperators.AddedOperator","text":"Lazy operator addition\n\n(A1 + A2 + A3...)u = A1*u + A2*u + A3*u ....\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.AddedScalarOperator","page":"API","title":"SciMLOperators.AddedScalarOperator","text":"struct AddedScalarOperator{T, O} <: SciMLOperators.AbstractSciMLScalarOperator{T}\n\nLazy addition of AbstractSciMLScalarOperators\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.AdjointOperator","page":"API","title":"SciMLOperators.AdjointOperator","text":"struct AdjointOperator{T, LType} <: SciMLOperators.AbstractSciMLOperator{T}\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.AffineOperator","page":"API","title":"SciMLOperators.AffineOperator","text":"L = AffineOperator(A, B, b; [update_func, update_func!, accepted_kwargs])\nL(u) = A*u + B*b\n\nRepresents a time-dependent affine operator. The update function is called by update_coefficients! and is assumed to have the following signature:\n\nupdate_func(b::AbstractArray,u,p,t; <accepted kwargs>) -> [modifies b]\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.BatchedDiagonalOperator","page":"API","title":"SciMLOperators.BatchedDiagonalOperator","text":"BatchedDiagonalOperator(diag; update_func, update_func!, accepted_kwargs)\n\nRepresents a time-dependent elementwise scaling (diagonal-scaling) operation. Acts on AbstractArrays of the same size as diag. The update function is called by update_coefficients! and is assumed to have the following signature:\n\nupdate_func(diag::AbstractArray, u, p, t; <accepted kwarg fields>) -> [modifies diag]\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.ComposedOperator","page":"API","title":"SciMLOperators.ComposedOperator","text":"Lazy operator composition\n\n∘(A, B, C)(u) = A(B(C(u)))\n\nops = (A, B, C)\ncache = (B*C*u , C*u)\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.ComposedScalarOperator","page":"API","title":"SciMLOperators.ComposedScalarOperator","text":"struct ComposedScalarOperator{T, O} <: SciMLOperators.AbstractSciMLScalarOperator{T}\n\nLazy multiplication of AbstractSciMLScalarOperators\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.FunctionOperator","page":"API","title":"SciMLOperators.FunctionOperator","text":"Matrix free operators (given by a function)\n\nop:  Function with signature op(u, p, t) and (if isinplace) op(du, u, p, t)\nop_adjoint:  Adjoint operator\nop_inverse:  Inverse operator\nop_adjoint_inverse:  Adjoint inverse operator\ntraits:  Traits\np:  Parameters\nt:  Time\ncache:  Cache\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.FunctionOperator-Union{Tuple{N}, Tuple{Any, AbstractVecOrMat}, Tuple{Any, AbstractVecOrMat, AbstractVecOrMat}} where N","page":"API","title":"SciMLOperators.FunctionOperator","text":"FunctionOperator(op, input)\nFunctionOperator(\n    op,\n    input,\n    output;\n    isinplace,\n    outofplace,\n    isconstant,\n    has_mul5,\n    cache,\n    T,\n    op_adjoint,\n    op_inverse,\n    op_adjoint_inverse,\n    p,\n    t,\n    accepted_kwargs,\n    ifcache,\n    islinear,\n    opnorm,\n    issymmetric,\n    ishermitian,\n    isposdef\n)\n\n\n\n\n\n\n","category":"method"},{"location":"api/#SciMLOperators.IdentityOperator","page":"API","title":"SciMLOperators.IdentityOperator","text":"struct IdentityOperator <: SciMLOperators.AbstractSciMLOperator{Bool}\n\nOperator representing the identity function id(u) = u\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.InvertedOperator","page":"API","title":"SciMLOperators.InvertedOperator","text":"Lazy Operator Inverse\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.InvertedScalarOperator","page":"API","title":"SciMLOperators.InvertedScalarOperator","text":"struct InvertedScalarOperator{T, λType} <: SciMLOperators.AbstractSciMLScalarOperator{T}\n\nLazy inverse of AbstractSciMLScalarOperators\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.InvertibleOperator","page":"API","title":"SciMLOperators.InvertibleOperator","text":"InvertibleOperator(L, F)\n\nStores an operator and its factorization (or inverse operator). Supports left division and ldiv! via F, and operator application via L.\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.MatrixOperator","page":"API","title":"SciMLOperators.MatrixOperator","text":"Represents a linear operator given by an AbstractMatrix that may be applied to an AbstractVecOrMat. Its state is updated by the user-provided update_func during operator evaluation (L([v,], u, p, t)), or by calls to update_coefficients[!](L, u, p, t). Both recursively call the update_function, update_func which is assumed to have the signature\n\nupdate_func(A::AbstractMatrix, u, p, t; <accepted kwargs>) -> newA\n\nor     update_func!(A::AbstractMatrix, u ,p , t; <accepted kwargs>) -> [modifies A]\n\nThe set of keyword-arguments accepted by update_func[!] must be provided to MatrixOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func[!] if accepted_kwargs are not provided.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nInterface\n\nLazy matrix algebra is defined for AbstractSciMLOperators. The Interface supports lazy addition, subtraction, multiplication, inversion, adjoints, transposes.\n\nExample\n\nu = rand(4)\np = rand(N, N)\nt = rand()\n\nmat_update = (A, u, p, t; scale = 0.0) -> t * p\nM = MatrixOperator(0.0; update_func = mat_update; accepted_kwargs = (:scale,))\n\nL = M * M + 3I\nL = cache_operator(M, u)\n\n# update L and evaluate\nv = L(u, p, t; scale = 1.0)\n\nv = zero(4)\nu = rand(4)\np = nothing\nt = rand()\n\nmat_update! = (A, u, p, t; scale = 0.0) -> (copy!(A, p); lmul!(t, A))\nM = MatrixOperator(0.0; update_func! = val_update!; accepted_kwargs = (:scale,))\nL = M * M + 3I\n\n# update L in-place and evaluate\nL(v, u, p, t; scale = 1.0)\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.NoKwargFilter","page":"API","title":"SciMLOperators.NoKwargFilter","text":"This type indicates to preprocess_update_func to not to filter keyword arguments. Required in implementation of lazy Base.adjoint, Base.conj, Base.transpose.\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.NullOperator","page":"API","title":"SciMLOperators.NullOperator","text":"struct NullOperator <: SciMLOperators.AbstractSciMLOperator{Bool}\n\nOperator representing the null function n(u) = 0 * u\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.ScalarOperator-Tuple{Any}","page":"API","title":"SciMLOperators.ScalarOperator","text":"ScalarOperator(val; update_func, accepted_kwargs)\n\n\nRepresents a linear scaling operator that may be applied to a Number, or an AbstractArray subtype. Its state is updated by the user-provided update_func during operator evaluation (L([v,] u, p, t)), or by calls to update_coefficients[!]. Both recursively call the  update function, update_func which is assumed to have the signautre:\n\nupdate_func(oldval::Number, u, p, t; <accepted kwargs>) -> newval\n\nThe set of keyword-arguments accepted by update_func must be provided to ScalarOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func if accepted_kwargs are not provided.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nInterface\n\nLazy scalar algebra is defined for AbstractSciMLScalarOperators. The interface supports lazy addition, subtraction, multiplication and division.\n\nExample\n\nv = zero(4)\nu = rand(4)\np = nothing\nt = 0.0\n\nval_update = (a, u, p, t; scale = 0.0) -> copy(scale)\nα = ScalarOperator(0.0; update_func = val_update; accepted_kwargs = (:scale,))\nβ = 2 * α + 3 / α\n\n# update L out-of-place, and evaluate\nβ(u, p, t; scale = 1.0)\n\n# update L in-place and evaluate\nβ(v, u, p, t; scale = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#SciMLOperators.ScaledOperator","page":"API","title":"SciMLOperators.ScaledOperator","text":"struct ScaledOperator{T, λType, LType} <: SciMLOperators.AbstractSciMLOperator{T}\n\nScaledOperator\n\n(λ L)*(u) = λ * L(u)\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.TensorProductOperator","page":"API","title":"SciMLOperators.TensorProductOperator","text":"Lazy Tensor Product Operator\n\nTensorProductOperator(A, B) = A ⊗ B\n\n(A ⊗ B)(u) = vec(B * U * transpose(A))\n\nwhere U is a lazy representation of the vector u as\na matrix with the appropriate size.\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLOperators.TransposedOperator","page":"API","title":"SciMLOperators.TransposedOperator","text":"struct TransposedOperator{T, LType} <: SciMLOperators.AbstractSciMLOperator{T}\n\n\n\n\n\n","category":"type"},{"location":"interface/#The-AbstractSciMLOperator-Interface","page":"Interface","title":"The AbstractSciMLOperator Interface","text":"","category":"section"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"update_coefficients\nupdate_coefficients!\ncache_operator","category":"page"},{"location":"interface/#Traits","page":"Interface","title":"Traits","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"isconstant\niscached\nissquare\nislinear\nhas_adjoint\nhas_expmv\nhas_expmv!\nhas_exp\nhas_mul\nhas_mul!\nhas_ldiv\nhas_ldiv!","category":"page"},{"location":"interface/#SciMLOperators.isconstant","page":"Interface","title":"SciMLOperators.isconstant","text":"isconstant(_)\n\n\nChecks if an operator's state is constant or not.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.iscached","page":"Interface","title":"SciMLOperators.iscached","text":"iscached(L)\n\n\nChecks whether L has preallocated caches for inplace evaluations.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.islinear","page":"Interface","title":"SciMLOperators.islinear","text":"islinear(_)\n\n\nChecks whether operator is linear or not.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Formal-Properties-of-SciMLOperators","page":"Interface","title":"Formal Properties of SciMLOperators","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"These are the formal properties that an AbstractSciMLOperator should obey for it to work in the solvers.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"An AbstractSciMLOperator represents a linear or nonlinear operator with input/output being AbstractArrays. Specifically, a SciMLOperator, L, of size (M,N) accepts input argument u with leading length N, i.e. size(u, 1) == N, and returns an AbstractArray of the same dimension with leading length M, i.e. size(L * u, 1) == M.\nSciMLOperators can be applied to an AbstractArray via overloaded Base.*, or the in-place LinearAlgebra.mul!. Additionally, operators are allowed to be time, or parameter dependent. The state of a SciMLOperator can be updated by calling the mutating function update_coefficients!(L, u, p, t) where p representes parameters, and t, time.  Calling a SciMLOperator as L(du, u, p, t) or out-of-place L(u, p, t) will automatically update the state of L before applying it to u. L(u, p, t) is the same operation as L(u, p, t) * u.\nTo support the update functionality, we have lazily implemented a comprehensive operator algebra. That means a user can add, subtract, scale, compose and invert SciMLOperators, and the state of the resultant operator would be updated as expected upon calling L(du, u, p, t) or L(u, p, t) so long as an update function is provided for the component operators.","category":"page"},{"location":"interface/#AbstractSciMLOperator-Interface-Description","page":"Interface","title":"AbstractSciMLOperator Interface Description","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"AbstractSciMLLinearOperator <: AbstractSciMLOperator\nAbstractSciMLScalarOperator <: AbstractSciMLLinearOperator\nisconstant(A) trait for whether the operator is constant or not.\nOptional: exp(A). Required for simple exponential integration.\nOptional: expv(A,u,t) = exp(t*A)*u and expv!(v,A::AbstractSciMLOperator,u,t) Required for sparse-saving exponential integration.\nOptional: factorizations. ldiv!, factorize et. al. This is only required for algorithms which use the factorization of the operator (Crank-Nicolson), and only for when the default linear solve is used.","category":"page"},{"location":"interface/#Note-About-Affine-Operators","page":"Interface","title":"Note About Affine Operators","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Affine operators are operators which have the action Q*x = A*x + b. These operators have no matrix representation, since if there was it would be a linear operator instead of an  affine operator. You can only represent an affine operator as a linear operator in a  dimension of one larger via the operation: [A b] * [u;1], so it would require something modified  to the input as well. As such, affine operators are a distinct generalization of linear operators.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"While it this seems like it might doom the idea of using matrix-free affine operators, it turns out  that affine operators can be used in all cases where matrix-free linear solvers are used due to an easy genearlization of the standard convergence proofs. If Q is the affine operator  Q(x) = Ax + b, then solving Qx = c is equivalent to solving Ax + b = c or Ax = c-b.  If you know do this same \"plug-and-chug\" handling of the affine operator in into the GMRES/CG/etc.  convergence proofs, move the affine part to the rhs residual, and show it converges to solving  Ax = c-b, and thus GMRES/CG/etc. solves Q(x) = c for an affine operator properly. ","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"That same trick then can be used pretty much anywhere you would've had a linear operator to extend  the proof to affine operators, so then exp(A*t)*v operations via Krylov methods work for A being  affine as well, and all sorts of things. Thus affine operators have no matrix representation but they  are still compatible with essentially any Krylov method which would otherwise be compatible with matrix-free representations, hence their support in the SciMLOperators interface.","category":"page"},{"location":"interface/#Note-about-keyword-arguments-to-update_coefficients!","page":"Interface","title":"Note about keyword arguments to update_coefficients!","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"In rare cases, an operator may be used in a context where additional state is expected to be provided to update_coefficients! beyond u, p, and t. In this case, the operator may accept this additional state through arbitrary keyword arguments to update_coefficients!. When the caller provides these, they will be recursively propagated downwards through composed operators just like u, p, and t, and provided to the operator. For the premade SciMLOperators, one can specify the keyword arguments used by an operator with an accepted_kwargs argument (by default, none are passed).","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"In the below example, we create an operator that gleefully ignores u, p, and t and uses its own special scaling.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"using SciMLOperators\n\nγ = ScalarOperator(0.0; update_func=(a, u, p, t; my_special_scaling) -> my_special_scaling,\n                   accepted_kwargs=(:my_special_scaling,))\n\n# Update coefficients, then apply operator\nupdate_coefficients!(γ, nothing, nothing, nothing; my_special_scaling=7.0)\n@show γ * [2.0]\n\n# Use operator application form\n@show γ([2.0], nothing, nothing; my_special_scaling = 5.0)\nnothing # hide","category":"page"},{"location":"premade_operators/#Premade-SciMLOperators","page":"Premade Operators","title":"Premade SciMLOperators","text":"","category":"section"},{"location":"premade_operators/#Direct-Operator-Definitions","page":"Premade Operators","title":"Direct Operator Definitions","text":"","category":"section"},{"location":"premade_operators/","page":"Premade Operators","title":"Premade Operators","text":"ScalarOperator.IdentityOperator\nSciMLOperators.NullOperator\nScalarOperator\nMatrixOperator\nDiagonalOperator\nAffineOperator\nAddVector\nFunctionOperator\nTensorProductOperator","category":"page"},{"location":"premade_operators/#SciMLOperators.ScalarOperator","page":"Premade Operators","title":"SciMLOperators.ScalarOperator","text":"ScalarOperator(val; update_func, accepted_kwargs)\n\n\nRepresents a linear scaling operator that may be applied to a Number, or an AbstractArray subtype. Its state is updated by the user-provided update_func during operator evaluation (L([v,] u, p, t)), or by calls to update_coefficients[!]. Both recursively call the  update function, update_func which is assumed to have the signautre:\n\nupdate_func(oldval::Number, u, p, t; <accepted kwargs>) -> newval\n\nThe set of keyword-arguments accepted by update_func must be provided to ScalarOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func if accepted_kwargs are not provided.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nInterface\n\nLazy scalar algebra is defined for AbstractSciMLScalarOperators. The interface supports lazy addition, subtraction, multiplication and division.\n\nExample\n\nv = zero(4)\nu = rand(4)\np = nothing\nt = 0.0\n\nval_update = (a, u, p, t; scale = 0.0) -> copy(scale)\nα = ScalarOperator(0.0; update_func = val_update; accepted_kwargs = (:scale,))\nβ = 2 * α + 3 / α\n\n# update L out-of-place, and evaluate\nβ(u, p, t; scale = 1.0)\n\n# update L in-place and evaluate\nβ(v, u, p, t; scale = 1.0)\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.DiagonalOperator","page":"Premade Operators","title":"SciMLOperators.DiagonalOperator","text":"DiagonalOperator(\n    diag;\n    update_func,\n    update_func!,\n    accepted_kwargs\n)\n\n\nRepresents a elementwise scaling (diagonal-scaling) operation that may be applied to an AbstractVecOrMat. When diag is an AbstractVector of length N, L = DiagonalOpeator(diag, ...) can be applied to AbstractArrays with size(u, 1) == N. Each column of the u will be scaled by diag, as in LinearAlgebra.Diagonal(diag) * u.\n\nWhen diag is a multidimensional array, L = DiagonalOperator(diag, ...) forms an operator of size (N, N) where N = size(diag, 1) is the leading length of diag. L then is the elementwise-scaling operation on arrays of length(u) = length(diag) with leading length size(u, 1) = N.\n\nIts state is updated by the user-provided update_func during operator evaluation (L([v,], u, p, t)), or by calls to update_coefficients[!](L, u, p, t). Both recursively call the update_function, update_func which is assumed to have the signature\n\nupdate_func(diag::AbstractVecOrMat, u, p, t; <accepted kwargs>) -> new_diag\n\nor     update_func!(diag::AbstractVecOrMat, u, p, t; <accepted kwargs>) -> [modifies diag]\n\nThe set of keyword-arguments accepted by update_func[!] must be provided to MatrixOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func[!] if accepted_kwargs are not provided.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nExample\n\n\n\n\n\n","category":"function"},{"location":"premade_operators/#SciMLOperators.AddVector","page":"Premade Operators","title":"SciMLOperators.AddVector","text":"L = AddVector(b; [update_func, update_func!, accepted_kwargs])\nL(u) = u + b\n\n\n\n\n\nL = AddVector(B, b; [update_func, accepted_kwargs])\nL(u) = u + B*b\n\n\n\n\n\n","category":"function"},{"location":"premade_operators/#Lazy-Scalar-Operator-Combination","page":"Premade Operators","title":"Lazy Scalar Operator Combination","text":"","category":"section"},{"location":"premade_operators/","page":"Premade Operators","title":"Premade Operators","text":"SciMLOperators.AddedScalarOperator\nSciMLOperators.ComposedScalarOperator\nSciMLOperators.InvertedScalarOperator","category":"page"},{"location":"premade_operators/#Lazy-Operator-Combination","page":"Premade Operators","title":"Lazy Operator Combination","text":"","category":"section"},{"location":"premade_operators/","page":"Premade Operators","title":"Premade Operators","text":"SciMLOperators.ScaledOperator\nSciMLOperators.AddedOperator\nSciMLOperators.ComposedOperator\nSciMLOperators.InvertedOperator\nSciMLOperators.InvertibleOperator\nSciMLOperators.AdjointOperator\nSciMLOperators.TransposedOperator","category":"page"},{"location":"tutorials/fftw/#Wrap-a-Fourier-transform-with-SciMLOperators","page":"FFT Tutorial","title":"Wrap a Fourier transform with SciMLOperators","text":"","category":"section"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"In this tutorial, we will wrap a Fast Fourier Transform (FFT) in a SciMLOperator via the FunctionOperator interface. FFTs are commonly used algorithms for performing numerical interpolation and differentiation. In this example, we will use the FFT to compute the derivative of a function.","category":"page"},{"location":"tutorials/fftw/#Copy-Paste-Code","page":"FFT Tutorial","title":"Copy-Paste Code","text":"","category":"section"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"using SciMLOperators\nusing LinearAlgebra, FFTW\n\nn = 256\nL = 2π\n\ndx = L / n\nx  = range(start=-L/2, stop=L/2-dx, length=n) |> Array\nu  = @. sin(5x)cos(7x);\ndu = @. 5cos(5x)cos(7x) - 7sin(5x)sin(7x);\n\nk  = rfftfreq(n, 2π*n/L) |> Array\nm  = length(k)\ntransform = plan_rfft(x)\n\nT = FunctionOperator((du,u,p,t) -> mul!(du, transform, u), x, im*k;\n                     isinplace=true,\n                     T=ComplexF64,\n\n                     op_adjoint = (du,u,p,t) -> ldiv!(du, transform, u),\n                     op_inverse = (du,u,p,t) -> ldiv!(du, transform, u),\n                     op_adjoint_inverse = (du,u,p,t) -> ldiv!(du, transform, u),\n                    )\n\nik = im * DiagonalOperator(k)\nDx = T \\ ik * T\n\nDx = cache_operator(Dx, x)\n\n@show ≈(Dx * u, du; atol=1e-8)\n@show ≈(mul!(copy(u), Dx, u), du; atol=1e-8)","category":"page"},{"location":"tutorials/fftw/#Explanation","page":"FFT Tutorial","title":"Explanation","text":"","category":"section"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"We load SciMLOperators, LinearAlgebra, and FFTW (short for Fastest Fourier Transform in the West), a common Fourier transform library. Next, we define an equispaced grid from -π to π, and write the function u that we intend to differentiate. Since this is a trivial example, we already know the derivative, du and write it down to later test our FFT wrapper.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"using SciMLOperators\nusing LinearAlgebra, FFTW\n\nL  = 2π\nn  = 256\ndx = L / n\nx  = range(start=-L/2, stop=L/2-dx, length=n) |> Array\n\nu  = @. sin(5x)cos(7x);\ndu = @. 5cos(5x)cos(7x) - 7sin(5x)sin(7x);\n","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"Now, we define the Fourier transform. Since our input is purely Real, we use the real Fast Fourier Transform. The funciton plan_rfft outputs a real fast fourier transform object that can be applied to inputs that are like x as follows: xhat = transform * x, and LinearAlgebra.mul!(xhat, transform, x).  We also get k, the frequency modes sampled by our finite grid, via the function rfftfreq.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"k  = rfftfreq(n, 2π*n/L) |> Array\nm  = length(k)\ntr = plan_rfft(x)","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"Now we are ready to define our wrapper for the FFT object. To FunctionOperator, we pass the in-place forward application of the transform, (du,u,p,t) -> mul!(du, transform, u), its inverse application, (du,u,p,t) -> ldiv!(du, transform, u), as well as input and output prototype vectors. We also set the flag isinplace to true to signal that we intend to use the operator in a non-allocating way, and pass in the element-type and size of the operator.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"T = FunctionOperator((du,u,p,t) -> mul!(du, transform, u), x, im*k;\n                     isinplace=true,\n                     T=ComplexF64,\n\n                     op_adjoint = (du,u,p,t) -> ldiv!(du, transform, u),\n                     op_inverse = (du,u,p,t) -> ldiv!(du, transform, u),\n                     op_adjoint_inverse = (du,u,p,t) -> ldiv!(du, transform, u),\n                    )","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"After wrapping the FFT with FunctionOperator, we are ready to compose it with other SciMLOperators. Below we form the derivative operator, and cache it via the function cache_operator that requires an input prototype. We can test our derivative operator both in-place, and out-of-place by comparing its output to the analytical derivative.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"ik = im * DiagonalOperator(k)\nDx = T \\ ik * T\n\n@show ≈(Dx * u, du; atol=1e-8)\n@show ≈(mul!(copy(u), Dx, u), du; atol=1e-8)","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"≈(Dx * u, du; atol = 1.0e-8) = true\n≈(mul!(copy(u), Dx, u), du; atol = 1.0e-8) = true","category":"page"},{"location":"#SciMLOperators.jl:-The-SciML-Operators-Interface","page":"Home","title":"SciMLOperators.jl: The SciML Operators Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SciMLOperators","category":"page"},{"location":"#SciMLOperators","page":"Home","title":"SciMLOperators","text":"SciMLOperators.jl\n\nUnified operator interface for SciML.ai and beyond\n\n(Image: Join the chat at https://julialang.zulipchat.com #sciml-bridged) (Image: Global Docs)\n\n(Image: codecov) (Image: Build Status)\n\n(Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages) (Image: SciML Code Style)\n\nSciMLOperators is a package for managing linear, nonlinear, time-dependent, and parameter dependent operators acting on vectors, (or column-vectors of matrices). We provide wrappers for matrix-free operators, fast tensor-product evaluations, pre-cached mutating evaluations, as well as Zygote-compatible non-mutating evaluations.\n\nThe lazily implemented operator algebra allows the user to update the operator state by passing in an update function that accepts arbirary parameter objects. Further, our operators behave like AbstractMatrix types thanks to  overloads defined for methods in Base, and LinearAlgebra.\n\nTherefore, an AbstractSciMLOperator can be passed to LinearSolve.jl, or NonlinearSolve.jl as a linear/nonlinear operator, or to OrdinaryDiffEq.jl as an ODEFunction. Examples of usage within the SciML ecosystem are provided in the documentation.\n\nInstallation\n\nSciMLOperators.jl is a registerd package and can be installed via\n\njulia> import Pkg\njulia> Pkg.add(\"SciMLOperators\")\n\nExamples\n\nLet M, D, F be matrix, diagonal matrix, and function-based SciMLOperators respectively.\n\nN = 4\nf = (u, p, t) -> u .* u\n\nM = MatrixOperator(rand(N, N))\nD = DiagonalOperator(rand(N))\nF = FunctionOperator(f, zeros(N), zeros(N))\n\nThen, the following codes just work.\n\nL1 = 2M + 3F + LinearAlgebra.I + rand(N, N)\nL2 = D * F * M'\nL3 = kron(M, D, F)\nL4 = M \\ D\nL5 = [M; D]' * [M F; F D] * [F; D]\n\nEach L# can be applied to AbstractVectors of appropriate sizes:\n\np = nothing # parameter struct\nt = 0.0     # time\n\nu = rand(N)\nv = L1(u, p, t) # == L1 * u\n\nu_kron = rand(N ^ 3)\nv_kron = L3(u_kron, p, t) # == L3 * u_kron\n\nFor mutating operator evaluations, call cache_operator to generate in-place cache so the operation is nonallocating.\n\nα, β = rand(2)\n\n# allocate cache\nL2 = cache_operator(L2, u)\nL4 = cache_operator(L4, u)\n\n# allocation-free evaluation\nL2(v, u, p, t) # == mul!(v, L2, u)\nL4(v, u, p, t, α, β) # == mul!(v, L4, u, α, β)\n\nThe calling signature L(u, p, t), for out-of-place evaluations is equivalent to L * u, and the in-place evaluation L(v, u, p, t, args...) is equivalent to LinearAlgebra.mul!(v, L, u, args...), where the arguments p, t are passed to L to update its state. More details are provided in the operator update section below. While overloads to Base.* and LinearAlgebra.mul! are available, where a SciMLOperator behaves like an AbstractMatrix, we recommend sticking with the L(u, p, t), L(v, u, p, t), L(v, u, p, t, α, β) calling signatures as the latter internally update the operator state.\n\nThe (u, p, t) calling signature is standardized over the SciML ecosystem and is flexible enough to support use cases such as time-evolution in ODEs, as well as sensitivity computation with respect to the parameter object p.\n\nThanks to overloads defined for evaluation methods and traits in Base, LinearAlgebra, the behaviour of a SciMLOperator is indistinguishable from an AbstractMatrix. These operators can be passed to linear solver packages, and even to ordinary differential equation solvers. The list of overloads to the AbstractMatrix interface include, but are not limited, the following:\n\nBase: size, zero, one, +, -, *, /, \\, ∘, inv, adjoint, transpose, convert\nLinearAlgebra: mul!, ldiv!, lmul!, rmul!, factorize, issymmetric, ishermitian, isposdef\nSparseArrays: sparse, issparse\n\nMultidimension arrays and batching\n\nSciMLOperator can also be applied to AbstractMatrix subtypes where operator-evaluation is done column-wise.\n\nK = 10\nu_mat = rand(N, K)\n\nv_mat = F(u_mat, p, t) # == mul!(v_mat, F, u_mat)\nsize(v_mat) == (N, K) # true\n\nL# can also be applied to AbstractArrays that are not AbstractVecOrMats so long as their size in the first dimension is appropriate for matrix-multiplication. Internally, SciMLOperators reshapes an N-dimensional array to an AbstractMatrix, and applies the operator via matrix-multiplication.\n\nOperator update\n\nThis package can also be used to write time-dependent, and parameter-dependent operators, whose state can be updated per a user-defined function. The updates can be done in-place, i.e. by mutating the object, or out-of-place, i.e. in a non-mutating, Zygote-compatible way.\n\nFor example,\n\nu = rand(N)\np = rand(N)\nt = rand()\n\n# out-of-place update\nmat_update_func = (A, u, p, t) -> t * (p * p')\nsca_update_func = (a, u, p, t) -> t * sum(p)\n\nM = MatrixOperator(zero(N, N); update_func = mat_update_func)\nα = ScalarOperator(zero(Float64); update_func = sca_update_func)\n\nL = α * M\nL = cache_operator(L, u)\n\n# L is initialized with zero state\nL * u == zeros(N) # true\n\n# update operator state with `(u, p, t)`\nL = update_coefficients(L, u, p, t)\n# and multiply\nL * u != zeros(N) # true\n\n# updates state and evaluates L at (u, p, t)\nL(u, p, t) != zeros(N) # true\n\nThe out-of-place evaluation function L(u, p, t) calls update_coefficients under the hood, which recursively calls the update_func for each component SciMLOperator. Therefore the out-of-place evaluation function is equivalent to calling update_coefficients followed by Base.*. Notice that the out-of-place evaluation does not return the updated operator.\n\nOn the other hand,, the in-place evaluation function, L(v, u, p, t), mutates L, and is equivalent to calling update_coefficients! followed by mul!. The in-place update behaviour works the same way with a few <!>s appended here and there. For example,\n\nv = rand(N)\nu = rand(N)\np = rand(N)\nt = rand()\n\n# in-place update\n_A = rand(N, N)\n_d = rand(N)\nmat_update_func!  = (A, u, p, t) -> (copy!(A, _A); lmul!(t, A); nothing)\ndiag_update_func! = (diag, u, p, t) -> copy!(diag, N)\n\nM = MatrixOperator(zero(N, N); update_func! = mat_update_func!)\nD = DiagonalOperator(zero(N); update_func! = diag_update_func!)\n\nL = D * M\nL = cache_operator(L, u)\n\n# L is initialized with zero state\nL * u == zeros(N) # true\n\n# update L in-place\nupdate_coefficients!(L, u, p, t)\n# and multiply\nmul!(v, u, p, t) != zero(N) # true\n\n# updates L in-place, and evaluates at (u, p, t)\nL(v, u, p, t) != zero(N) # true\n\nThe update behaviour makes this package flexible enough to be used in OrdianryDiffEq. As the parameter object p is often reserved for sensitivy computation via automatic-differentiation, a user may prefer to pass in state information via other arguments. For that reason, we allow for update functions with arbitrary keyword arguments.\n\nmat_update_func = (A, u, p, t; scale = 0.0) -> scale * (p * p')\n\nM = MatrixOperator(zero(N, N); update_func = mat_update_func,\n                   accepted_kwargs = (:state,))\n\nM(u, p, t) == zeros(N) # true\nM(u, p, t; scale = 1.0) != zero(N)\n\nFeatures\n\nMatrix-free operators with FunctionOperator\nFast tensor product evaluation\nMutating, nonmutating update behaviour (Zygote compatible)\nInvertibleOperator - pair fwd, bwd operators\nLazy algebra: addition, subtraction, multiplication, inverse, adjoint\nPre-caching methods for in-place evaluations\n\nWhy SciMLOperators?\n\nMany functions, from linear solvers to differential equations, require the use of matrix-free operators in order to achieve maximum performance in many scenarios. SciMLOperators.jl defines the abstract interface for how operators in the SciML ecosystem are supposed to be defined. It gives the common set of functions and traits which solvers can rely on for properly performing their tasks. Along with that, SciMLOperators.jl provides definitions for the basic standard operators which are used in building blocks for most tasks, both simplifying the use of operators while also demonstrating to users how such operators can be built and used in practice.\n\nSciMLOperators.jl has the design that is required in order to be used in all scenarios of equation solvers. For example, Magnus integrators for differential equations require defining an operator u = A(t) u, while Munthe-Kaas methods require defining operators of the form u = A(u) u. Thus the operators need some form of time and state dependence which the solvers can update and query when they are non-constant (update_coefficients!). Additionally, the operators need the ability to act like \"normal\" functions for equation solvers. For example, if A(u,p,t) has the same operation as update_coefficients(A, u, p, t); A * u, then A can be used in any place where a differential equation definition f(u, p, t) is used without requring the user or solver to do any extra work. Thus while previous good efforts for matrix-free operators have existed in the Julia ecosystem, such as LinearMaps.jl, those operator interfaces lack these aspects in order to actually be fully seamless with downstream equation solvers. This necessitates the definition and use of an extended operator interface with all of these properties, hence the AbstractSciMLOperator interface.\n\nSome packages providing similar functionality are\n\nLinearMaps.jl\nDiffEqOperators.jl (deprecated)\n\nInteroperability and extended Julia ecosystem\n\nSciMLOperator.jl overloads the AbstractMatrix interface for AbstractSciMLOperators, allowing seamless compatibility with linear solves, and nonlinear solvers. Further, due to the update functionality, AbstractSciMLOperators can represent an ODEFunction in OrdinaryDiffEq.jl, and downstream packages. See tutorials for example of usage with OrdinaryDiffEq.jl, LinearSolve.jl, NonlinearSolve.jl.\n\nFurther, the nonmutating update functionality allows gradient propogation through AbstractSciMLOperators, and is compatible with automatic-differentiation libraries like Zygote.jl. An example of Zygote.jl usage with Lux.jl is also provided in the tutorials.\n\nPlease make an issue here if you come across an unexpected issue while using SciMLOperators.\n\nWe provide below a list of packages that make use of SciMLOperators. If you are using SciMLOperators in your work, feel free to create a PR and add your package to this list.\n\nSciML.ai ecosystem: SciMLOperators is compatible with, and utilized by every SciML package.\nCalculustJL packages use SciMLOperators to define matrix-free vector-calculus operators for solving partial differential equations.\nCalculustCore.jl\nFourierSpaces.jl\nNodalPolynomialSpaces.jl\nSparseDiffTools.jl\n\nRoadmap\n\n[ ] Complete integration with SciML ecosystem\n[ ] Block-matrices\n[x] Benchmark and speed-up tensorbproduct evaluations\n[ ] Fast tensor-sum (kronsum) evaluation\n[ ] Fully flesh out operator array algebra\n[ ] Operator fusion/matrix chain multiplication at constant (u, p, t)-slices\n\nContributing\n\nPlease refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nJuliaDiffEq on Gitter\nOn the Julia Discourse forums (look for the modelingtoolkit tag\nSee also SciML Community page\n\n\n\n\n\n","category":"module"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(;mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also download the \n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">project</a> file.","category":"page"}]
}
