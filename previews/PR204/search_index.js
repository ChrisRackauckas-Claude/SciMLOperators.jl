var documenterSearchIndex = {"docs":
[{"location":"interface/#The-AbstractSciMLOperator-Interface","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"","category":"section"},{"location":"interface/#Formal-Properties-of-SciMLOperators","page":"The AbstractSciMLOperator Interface","title":"Formal Properties of SciMLOperators","text":"","category":"section"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"These are the formal properties that an AbstractSciMLOperator should obey for it to work in the solvers.","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"An AbstractSciMLOperator represents a linear or nonlinear operator with input/output being AbstractArrays. Specifically, a SciMLOperator, L, of size (M, N) accepts input argument u with leading length N, i.e. size(u, 1) == N, and returns an AbstractArray of the same dimension with leading length M, i.e. size(L * u, 1) == M.\nSciMLOperators can be applied to an AbstractArray via overloaded Base.*, or the in-place LinearAlgebra.mul!. Additionally, operators are allowed to be time, or parameter dependent. The state of a SciMLOperator can be updated by calling the mutating function update_coefficients!(L, u, p, t) where p representes parameters, and t, time.  Calling a SciMLOperator as L(du, u, p, t) or out-of-place L(u, p, t) will automatically update the state of L before applying it to u. L(u, p, t) is the same operation as L(u, p, t) * u.\nTo support the update functionality, we have lazily implemented a comprehensive operator algebra. That means a user can add, subtract, scale, compose and invert SciMLOperators, and the state of the resultant operator would be updated as expected upon calling L(du, u, p, t) or L(u, p, t) so long as an update function is provided for the component operators.","category":"page"},{"location":"interface/#Overloaded-Traits","page":"The AbstractSciMLOperator Interface","title":"Overloaded Traits","text":"","category":"section"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"Thanks to overloads defined for evaluation methods and traits in Base, LinearAlgebra, the behaviour of a SciMLOperator is indistinguishable from an AbstractMatrix. These operators can be passed to linear solver packages, and even to ordinary differential equation solvers. The list of overloads to the AbstractMatrix interface include, but are not limited, the following:","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"Base: size, zero, one, +, -, *, /, \\, ∘, inv, adjoint, transpose, convert\nLinearAlgebra: mul!, ldiv!, lmul!, rmul!, factorize, issymmetric, ishermitian, isposdef\nSparseArrays: sparse, issparse","category":"page"},{"location":"interface/#Multidimension-arrays-and-batching","page":"The AbstractSciMLOperator Interface","title":"Multidimension arrays and batching","text":"","category":"section"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"SciMLOperator can also be applied to AbstractMatrix subtypes where operator-evaluation is done column-wise.","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"K = 10\nu_mat = rand(N, K)\n\nv_mat = F(u_mat, p, t) # == mul!(v_mat, F, u_mat)\nsize(v_mat) == (N, K) # true","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"L# can also be applied to AbstractArrays that are not AbstractVecOrMats so long as their size in the first dimension is appropriate for matrix-multiplication. Internally, SciMLOperators reshapes an N-dimensional array to an AbstractMatrix, and applies the operator via matrix-multiplication.","category":"page"},{"location":"interface/#Operator-update","page":"The AbstractSciMLOperator Interface","title":"Operator update","text":"","category":"section"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"This package can also be used to write time-dependent, and parameter-dependent operators, whose state can be updated per a user-defined function. The updates can be done in-place, i.e. by mutating the object, or out-of-place, i.e. in a non-mutating, Zygote-compatible way.","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"For example,","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"u = rand(N)\np = rand(N)\nt = rand()\n\n# out-of-place update\nmat_update_func = (A, u, p, t) -> t * (p * p')\nsca_update_func = (a, u, p, t) -> t * sum(p)\n\nM = MatrixOperator(zero(N, N); update_func = mat_update_func)\nα = ScalarOperator(zero(Float64); update_func = sca_update_func)\n\nL = α * M\nL = cache_operator(L, u)\n\n# L is initialized with zero state\nL * u == zeros(N) # true\n\n# update operator state with `(u, p, t)`\nL = update_coefficients(L, u, p, t)\n# and multiply\nL * u != zeros(N) # true\n\n# updates state and evaluates L at (u, p, t)\nL(u, p, t) != zeros(N) # true","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"The out-of-place evaluation function L(u, p, t) calls update_coefficients under the hood, which recursively calls the update_func for each component SciMLOperator. Therefore the out-of-place evaluation function is equivalent to calling update_coefficients followed by Base.*. Notice that the out-of-place evaluation does not return the updated operator.","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"On the other hand,, the in-place evaluation function, L(v, u, p, t), mutates L, and is equivalent to calling update_coefficients! followed by mul!. The in-place update behaviour works the same way with a few <!>s appended here and there. For example,","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"v = rand(N)\nu = rand(N)\np = rand(N)\nt = rand()\n\n# in-place update\n_A = rand(N, N)\n_d = rand(N)\nmat_update_func!  = (A, u, p, t) -> (copy!(A, _A); lmul!(t, A); nothing)\ndiag_update_func! = (diag, u, p, t) -> copy!(diag, N)\n\nM = MatrixOperator(zero(N, N); update_func! = mat_update_func!)\nD = DiagonalOperator(zero(N); update_func! = diag_update_func!)\n\nL = D * M\nL = cache_operator(L, u)\n\n# L is initialized with zero state\nL * u == zeros(N) # true\n\n# update L in-place\nupdate_coefficients!(L, u, p, t)\n# and multiply\nmul!(v, u, p, t) != zero(N) # true\n\n# updates L in-place, and evaluates at (u, p, t)\nL(v, u, p, t) != zero(N) # true","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"The update behaviour makes this package flexible enough to be used in OrdianryDiffEq. As the parameter object p is often reserved for sensitivy computation via automatic-differentiation, a user may prefer to pass in state information via other arguments. For that reason, we allow for update functions with arbitrary keyword arguments.","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"mat_update_func = (A, u, p, t; scale = 0.0) -> scale * (p * p')\n\nM = MatrixOperator(zero(N, N); update_func = mat_update_func,\n                   accepted_kwargs = (:state,))\n\nM(u, p, t) == zeros(N) # true\nM(u, p, t; scale = 1.0) != zero(N)","category":"page"},{"location":"interface/#Interface-API-Reference","page":"The AbstractSciMLOperator Interface","title":"Interface API Reference","text":"","category":"section"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"update_coefficients\nupdate_coefficients!\ncache_operator","category":"page"},{"location":"interface/#SciMLOperators.update_coefficients","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.update_coefficients","text":"update_coefficients(L, u, p, t; kwargs...)\n\n\nUpdate the state of L based on u, input vector, p parameter object, t, and keyword arguments. Internally, update_coefficients calls the user-provided update_func method for every component operator in L with the positional arguments (u, p, t) and keyword arguments corresponding to the symbols provided to the operator via kwarg accepted_kwargs.\n\nThis method is out-of-place, i.e. fully non-mutating and Zygote-compatible.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nExample\n\nusing SciMLOperator\n\nmat_update_func = (A, u, p, t; scale = 1.0) -> p * p' * scale * t\n\nM = MatrixOperator(zeros(4,4); update_func = mat_update_func,\n                   accepted_kwargs = (:state,))\n\nL = M + IdentityOperator(4)\n\nu = rand(4)\np = rand(4)\nt = 1.0\n\nL = update_coefficients(L, u, p, t; scale = 2.0)\nL * u\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.update_coefficients!","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.update_coefficients!","text":"update_coefficients!(L, u, p, t; kwargs...)\n\n\nUpdate in-place the state of L based on u, input vector, p parameter object, t, and keyword arguments. Internally, update_coefficients! calls the user-provided mutating update_func! method for every component operator in L with the positional arguments (u, p, t) and keyword arguments corresponding to the symbols provided to the operator via kwarg accepted_kwargs.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nExample\n\nusing SciMLOperator\n\n_A = rand(4, 4)\nmat_update_func! = (L, u, p, t; scale = 1.0) -> copy!(A, _A)\n\nM = MatrixOperator(zeros(4,4); update_func! = mat_update_func!)\n\nL = M + IdentityOperator(4)\n\nu = rand(4)\np = rand(4)\nt = 1.0\n\nupdate_coefficients!(L, u, p, t)\nL * u\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.cache_operator","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.cache_operator","text":"cache_operator(L, u)\n\n\nAllocate caches for L for in-place evaluation with u-like input vectors.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Traits","page":"The AbstractSciMLOperator Interface","title":"Traits","text":"","category":"section"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"isconstant\niscached\nissquare\nislinear\nhas_adjoint\nhas_expmv\nhas_expmv!\nhas_exp\nhas_mul\nhas_mul!\nhas_ldiv\nhas_ldiv!","category":"page"},{"location":"interface/#SciMLOperators.isconstant","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.isconstant","text":"isconstant(_)\n\n\nChecks if an L's state is constant or needs to be updated by calling update_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.iscached","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.iscached","text":"iscached(L)\n\n\nChecks whether L has preallocated caches for inplace evaluations.\n\n\n\n\n\nCheck if SciMLOperator L has preallocated cache-arrays for in-place computation.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.issquare","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.issquare","text":"Checks if size(L, 1) == size(L, 2).\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.islinear","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.islinear","text":"islinear(_)\n\n\nChecks if L is a linear operator.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_adjoint","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_adjoint","text":"Check if adjoint(L) is lazily defined.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_expmv","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_expmv","text":"Check if expmv(L, u, t), equivalent to exp(t * A) * u, is defined for Number t, and AbstractArray u of appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_expmv!","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_expmv!","text":"Check if expmv!(v, L, u, t), equivalent to mul!(v, exp(t * A), u), is defined for Number t, and AbstractArrays u, v of appropriate sizes.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_exp","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_exp","text":"Check if exp(L) is defined lazily defined.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_mul","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_mul","text":"Check if L * u is defined for AbstractArray u of appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_mul!","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_mul!","text":"Check if mul!(v, L, u) is defined for AbstractArrays u, v of appropriate sizes.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_ldiv","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_ldiv","text":"Check if L \\ u is defined for AbstractArray u of appropriate size.\n\n\n\n\n\n","category":"function"},{"location":"interface/#SciMLOperators.has_ldiv!","page":"The AbstractSciMLOperator Interface","title":"SciMLOperators.has_ldiv!","text":"Check if ldiv!(v, L, u) is defined for AbstractArrays u, v of appropriate sizes.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Note-About-Affine-Operators","page":"The AbstractSciMLOperator Interface","title":"Note About Affine Operators","text":"","category":"section"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"Affine operators are operators which have the action Q*x = A*x + b. These operators have no matrix representation, since if there was it would be a linear operator instead of an  affine operator. You can only represent an affine operator as a linear operator in a  dimension of one larger via the operation: [A b] * [u;1], so it would require something modified  to the input as well. As such, affine operators are a distinct generalization of linear operators.","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"While it this seems like it might doom the idea of using matrix-free affine operators, it turns out  that affine operators can be used in all cases where matrix-free linear solvers are used due to an easy genearlization of the standard convergence proofs. If Q is the affine operator  Q(x) = Ax + b, then solving Qx = c is equivalent to solving Ax + b = c or Ax = c-b.  If you know do this same \"plug-and-chug\" handling of the affine operator in into the GMRES/CG/etc.  convergence proofs, move the affine part to the rhs residual, and show it converges to solving  Ax = c-b, and thus GMRES/CG/etc. solves Q(x) = c for an affine operator properly. ","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"That same trick then can be used pretty much anywhere you would've had a linear operator to extend  the proof to affine operators, so then exp(A*t)*v operations via Krylov methods work for A being  affine as well, and all sorts of things. Thus affine operators have no matrix representation but they  are still compatible with essentially any Krylov method which would otherwise be compatible with matrix-free representations, hence their support in the SciMLOperators interface.","category":"page"},{"location":"interface/#Note-about-keyword-arguments-to-update_coefficients!","page":"The AbstractSciMLOperator Interface","title":"Note about keyword arguments to update_coefficients!","text":"","category":"section"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"In rare cases, an operator may be used in a context where additional state is expected to be provided to update_coefficients! beyond u, p, and t. In this case, the operator may accept this additional state through arbitrary keyword arguments to update_coefficients!. When the caller provides these, they will be recursively propagated downwards through composed operators just like u, p, and t, and provided to the operator. For the premade SciMLOperators, one can specify the keyword arguments used by an operator with an accepted_kwargs argument (by default, none are passed).","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"In the below example, we create an operator that gleefully ignores u, p, and t and uses its own special scaling.","category":"page"},{"location":"interface/","page":"The AbstractSciMLOperator Interface","title":"The AbstractSciMLOperator Interface","text":"using SciMLOperators\n\nγ = ScalarOperator(0.0; update_func=(a, u, p, t; my_special_scaling) -> my_special_scaling,\n                   accepted_kwargs=(:my_special_scaling,))\n\n# Update coefficients, then apply operator\nupdate_coefficients!(γ, nothing, nothing, nothing; my_special_scaling=7.0)\n@show γ * [2.0]\n\n# Use operator application form\n@show γ([2.0], nothing, nothing; my_special_scaling = 5.0)\nnothing # hide","category":"page"},{"location":"premade_operators/#Premade-SciMLOperators","page":"Premade Operators","title":"Premade SciMLOperators","text":"","category":"section"},{"location":"premade_operators/#Direct-Operator-Definitions","page":"Premade Operators","title":"Direct Operator Definitions","text":"","category":"section"},{"location":"premade_operators/","page":"Premade Operators","title":"Premade Operators","text":"ScalarOperator.IdentityOperator\nSciMLOperators.NullOperator\nScalarOperator\nMatrixOperator\nDiagonalOperator\nAffineOperator\nAddVector\nFunctionOperator\nTensorProductOperator","category":"page"},{"location":"premade_operators/#SciMLOperators.NullOperator","page":"Premade Operators","title":"SciMLOperators.NullOperator","text":"struct NullOperator <: SciMLOperators.AbstractSciMLOperator{Bool}\n\nOperator representing the null function n(u) = 0 * u\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.ScalarOperator","page":"Premade Operators","title":"SciMLOperators.ScalarOperator","text":"ScalarOperator(val; update_func, accepted_kwargs)\n\n\nRepresents a linear scaling operator that may be applied to a Number, or an AbstractArray subtype. Its state is updated by the user-provided update_func during operator evaluation (L([v,] u, p, t)), or by calls to update_coefficients[!]. Both recursively call the  update function, update_func which is assumed to have the signautre:\n\nupdate_func(oldval::Number, u, p, t; <accepted kwargs>) -> newval\n\nThe set of keyword-arguments accepted by update_func must be provided to ScalarOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func if accepted_kwargs are not provided.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nInterface\n\nLazy scalar algebra is defined for AbstractSciMLScalarOperators. The interface supports lazy addition, subtraction, multiplication and division.\n\nExample\n\nv = zero(4)\nu = rand(4)\np = nothing\nt = 0.0\n\nval_update = (a, u, p, t; scale = 0.0) -> copy(scale)\nα = ScalarOperator(0.0; update_func = val_update; accepted_kwargs = (:scale,))\nβ = 2 * α + 3 / α\n\n# update L out-of-place, and evaluate\nβ(u, p, t; scale = 1.0)\n\n# update L in-place and evaluate\nβ(v, u, p, t; scale = 1.0)\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.MatrixOperator","page":"Premade Operators","title":"SciMLOperators.MatrixOperator","text":"Represents a linear operator given by an AbstractMatrix that may be applied to an AbstractVecOrMat. Its state is updated by the user-provided update_func during operator evaluation (L([v,], u, p, t)), or by calls to update_coefficients[!](L, u, p, t). Both recursively call the update_function, update_func which is assumed to have the signature\n\nupdate_func(A::AbstractMatrix, u, p, t; <accepted kwargs>) -> newA\n\nor\n\nupdate_func!(A::AbstractMatrix, u ,p , t; <accepted kwargs>) -> [modifies A]\n\nThe set of keyword-arguments accepted by update_func[!] must be provided to MatrixOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func[!] if accepted_kwargs are not provided.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nInterface\n\nLazy matrix algebra is defined for AbstractSciMLOperators. The Interface supports lazy addition, subtraction, multiplication, inversion, adjoints, transposes.\n\nExample\n\nOut-of-place update and usage\n\nu = rand(4)\np = rand(4, 4)\nt = rand()\n\nmat_update = (A, u, p, t; scale = 0.0) -> t * p\nM = MatrixOperator(0.0; update_func = mat_update; accepted_kwargs = (:scale,))\n\nL = M * M + 3I\nL = cache_operator(M, u)\n\n# update L and evaluate\nv = L(u, p, t; scale = 1.0)\n\nIn-place update and usage\n\nv = zero(4)\nu = rand(4)\np = nothing\nt = rand()\n\nmat_update! = (A, u, p, t; scale = 0.0) -> (copy!(A, p); lmul!(t, A))\nM = MatrixOperator(zeros(4, 4); update_func! = val_update!; accepted_kwargs = (:scale,))\nL = M * M + 3I\n\n# update L in-place and evaluate\nL(v, u, p, t; scale = 1.0)\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.DiagonalOperator","page":"Premade Operators","title":"SciMLOperators.DiagonalOperator","text":"DiagonalOperator(\n    diag;\n    update_func,\n    update_func!,\n    accepted_kwargs\n)\n\n\nRepresents a elementwise scaling (diagonal-scaling) operation that may be applied to an AbstractVecOrMat. When diag is an AbstractVector of length N, L = DiagonalOpeator(diag, ...) can be applied to AbstractArrays with size(u, 1) == N. Each column of the u will be scaled by diag, as in LinearAlgebra.Diagonal(diag) * u.\n\nWhen diag is a multidimensional array, L = DiagonalOperator(diag, ...) forms an operator of size (N, N) where N = size(diag, 1) is the leading length of diag. L then is the elementwise-scaling operation on arrays of length(u) = length(diag) with leading length size(u, 1) = N.\n\nIts state is updated by the user-provided update_func during operator evaluation (L([v,], u, p, t)), or by calls to update_coefficients[!](L, u, p, t). Both recursively call the update_function, update_func which is assumed to have the signature\n\nupdate_func(diag::AbstractVecOrMat, u, p, t; <accepted kwargs>) -> new_diag\n\nor\n\nupdate_func!(diag::AbstractVecOrMat, u, p, t; <accepted kwargs>) -> [modifies diag]\n\nThe set of keyword-arguments accepted by update_func[!] must be provided to MatrixOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func[!] if accepted_kwargs are not provided.\n\nwarning: Warning\nThe user-provided update_func[!] must not use u in its computation. Positional argument (u, p, t) to update_func[!] are passed down by update_coefficients[!](L, u, p, t), where u is the input-vector to the composite AbstractSciMLOperator. For that reason, the values of u, or even shape, may not correspond to the input expected by update_func[!]. If an operator's state depends on its input vector, then it is, by definition, a nonlinear operator. We recommend sticking such nonlinearities in FunctionOperator. This topic is further discussed in (this issue)[https://github.com/SciML/SciMLOperators.jl/issues/159].\n\nExample\n\n\n\n\n\n","category":"function"},{"location":"premade_operators/#SciMLOperators.AffineOperator","page":"Premade Operators","title":"SciMLOperators.AffineOperator","text":"Represents a generalized affine operation (v = A * u + B * b) that may be applied to an AbstractVecOrMat. The user-provided update functions, update_func[!] update the AbstractVecOrMat b, and are called during during operator evaluation (L([v,], u, p, t)), or by calls to update_coefficients[!](L, u, p, t). The update functions are assumped to have the syntax\n\nupdate_func(b::AbstractVecOrMat, u, p, t; <accepted kwargs>) -> new_b\n\nor\n\nupdate_func!(b::AbstractVecOrMat, u ,p , t; <accepted kwargs>) -> [modifies b]\n\nand B, b are expected to have an appropriate size so that A * u + B * b makes sense. Specifically, size(A, 1) == size(B, 1), and size(u, 2) == size(b, 2).\n\nThe set of keyword-arguments accepted by update_func[!] must be provided to AffineOperator via the kwarg accepted_kwargs as a tuple of Symbols. kwargs cannot be passed down to update_func[!] if accepted_kwargs are not provided.\n\nExample\n\nu = rand(4)\np = rand(4)\nt = rand()\n\nA = MatrixOperator(rand(4, 4))\nB = MatrixOperator(rand(4, 4))\n\nvec_update_func = (b, u, p, t) -> p * t\nL = AffineOperator(A, B, zero(4); update_func = vec_update_func)\nL = cache_operator(M, u)\n\n# update L and evaluate\nv = L(u, p, t) # == A * u + B * (p * t)\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.AddVector","page":"Premade Operators","title":"SciMLOperators.AddVector","text":"AddVector(b; update_func, update_func!, accepted_kwargs)\n\n\nRepresents the affine operation v = I * u + I * b. The update functions, update_func[!] update the state of AbstractVecOrMat b. see documentation of AffineOperator for more details.\n\n\n\n\n\nAddVector(B, b; update_func, update_func!, accepted_kwargs)\n\n\nRepresents the affine operation v = I * u + B * b. The update functions, update_func[!] update the state of AbstractVecOrMat b. see documentation of AffineOperator for more details.\n\n\n\n\n\n","category":"function"},{"location":"premade_operators/#SciMLOperators.FunctionOperator","page":"Premade Operators","title":"SciMLOperators.FunctionOperator","text":"Matrix free operator given by a function\n\nop:  Function with signature op(u, p, t) and (if isinplace) op(v, u, p, t)\nop_adjoint:  Adjoint operator\nop_inverse:  Inverse operator\nop_adjoint_inverse:  Adjoint inverse operator\ntraits:  Traits\np:  Parameters\nt:  Time\ncache:  Cache\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.TensorProductOperator","page":"Premade Operators","title":"SciMLOperators.TensorProductOperator","text":"Computes the lazy pairwise Kronecker product, or tensor product, operator of AbstractMatrix, and AbstractSciMLOperator subtypes. Calling ⊗(ops...) is equivalent to Base.kron(ops...). Fast operator evaluation is performed without forming the full tensor product operator.\n\nTensorProductOperator(A, B) = A ⊗ B\nTensorProductOperator(A, B, C) = A ⊗ B ⊗ C\n\n(A ⊗ B)(u) = vec(B * reshape(u, M, N) * transpose(A))\n\nwhere M = size(B, 2), and N = size(A, 2)\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#Lazy-Scalar-Operator-Combination","page":"Premade Operators","title":"Lazy Scalar Operator Combination","text":"","category":"section"},{"location":"premade_operators/","page":"Premade Operators","title":"Premade Operators","text":"SciMLOperators.AddedScalarOperator\nSciMLOperators.ComposedScalarOperator\nSciMLOperators.InvertedScalarOperator","category":"page"},{"location":"premade_operators/#SciMLOperators.AddedScalarOperator","page":"Premade Operators","title":"SciMLOperators.AddedScalarOperator","text":"struct AddedScalarOperator{T, O} <: SciMLOperators.AbstractSciMLScalarOperator{T}\n\nLazy addition of AbstractSciMLScalarOperators\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.ComposedScalarOperator","page":"Premade Operators","title":"SciMLOperators.ComposedScalarOperator","text":"struct ComposedScalarOperator{T, O} <: SciMLOperators.AbstractSciMLScalarOperator{T}\n\nLazy multiplication of AbstractSciMLScalarOperators\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.InvertedScalarOperator","page":"Premade Operators","title":"SciMLOperators.InvertedScalarOperator","text":"struct InvertedScalarOperator{T, λType} <: SciMLOperators.AbstractSciMLScalarOperator{T}\n\nLazy inverse of AbstractSciMLScalarOperators\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#Lazy-Operator-Combination","page":"Premade Operators","title":"Lazy Operator Combination","text":"","category":"section"},{"location":"premade_operators/","page":"Premade Operators","title":"Premade Operators","text":"SciMLOperators.ScaledOperator\nSciMLOperators.AddedOperator\nSciMLOperators.ComposedOperator\nSciMLOperators.InvertedOperator\nSciMLOperators.InvertibleOperator\nSciMLOperators.AdjointOperator\nSciMLOperators.TransposedOperator","category":"page"},{"location":"premade_operators/#SciMLOperators.ScaledOperator","page":"Premade Operators","title":"SciMLOperators.ScaledOperator","text":"struct ScaledOperator{T, λType, LType} <: SciMLOperators.AbstractSciMLOperator{T}\n\nScaledOperator\n\n(λ L)*(u) = λ * L(u)\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.AddedOperator","page":"Premade Operators","title":"SciMLOperators.AddedOperator","text":"Lazy operator addition\n\n(A1 + A2 + A3...)u = A1*u + A2*u + A3*u ....\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.ComposedOperator","page":"Premade Operators","title":"SciMLOperators.ComposedOperator","text":"Lazy operator composition\n\n∘(A, B, C)(u) = A(B(C(u)))\n\nops = (A, B, C)\ncache = (B*C*u , C*u)\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.InvertedOperator","page":"Premade Operators","title":"SciMLOperators.InvertedOperator","text":"Lazy Operator Inverse\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.InvertibleOperator","page":"Premade Operators","title":"SciMLOperators.InvertibleOperator","text":"Stores an operator and its factorization (or inverse operator). Supports left division and ldiv! via F, and operator evaluation via L.\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.AdjointOperator","page":"Premade Operators","title":"SciMLOperators.AdjointOperator","text":"struct AdjointOperator{T, LType} <: SciMLOperators.AbstractSciMLOperator{T}\n\n\n\n\n\n","category":"type"},{"location":"premade_operators/#SciMLOperators.TransposedOperator","page":"Premade Operators","title":"SciMLOperators.TransposedOperator","text":"struct TransposedOperator{T, LType} <: SciMLOperators.AbstractSciMLOperator{T}\n\n\n\n\n\n","category":"type"},{"location":"tutorials/fftw/#Wrap-a-Fourier-transform-with-SciMLOperators","page":"FFT Tutorial","title":"Wrap a Fourier transform with SciMLOperators","text":"","category":"section"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"In this tutorial, we will wrap a Fast Fourier Transform (FFT) in a SciMLOperator via the FunctionOperator interface. FFTs are commonly used algorithms for performing numerical interpolation and differentiation. In this example, we will use the FFT to compute the derivative of a function.","category":"page"},{"location":"tutorials/fftw/#Copy-Paste-Code","page":"FFT Tutorial","title":"Copy-Paste Code","text":"","category":"section"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"using SciMLOperators\nusing LinearAlgebra, FFTW\n\nn = 256\nL = 2π\n\ndx = L / n\nx  = range(start=-L/2, stop=L/2-dx, length=n) |> Array\nu  = @. sin(5x)cos(7x);\ndu = @. 5cos(5x)cos(7x) - 7sin(5x)sin(7x);\n\nk  = rfftfreq(n, 2π*n/L) |> Array\nm  = length(k)\ntransform = plan_rfft(x)\n\nT = FunctionOperator((du,u,p,t) -> mul!(du, transform, u), x, im*k;\n                     isinplace=true,\n                     T=ComplexF64,\n\n                     op_adjoint = (du,u,p,t) -> ldiv!(du, transform, u),\n                     op_inverse = (du,u,p,t) -> ldiv!(du, transform, u),\n                     op_adjoint_inverse = (du,u,p,t) -> ldiv!(du, transform, u),\n                    )\n\nik = im * DiagonalOperator(k)\nDx = T \\ ik * T\n\nDx = cache_operator(Dx, x)\n\n@show ≈(Dx * u, du; atol=1e-8)\n@show ≈(mul!(copy(u), Dx, u), du; atol=1e-8)","category":"page"},{"location":"tutorials/fftw/#Explanation","page":"FFT Tutorial","title":"Explanation","text":"","category":"section"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"We load SciMLOperators, LinearAlgebra, and FFTW (short for Fastest Fourier Transform in the West), a common Fourier transform library. Next, we define an equispaced grid from -π to π, and write the function u that we intend to differentiate. Since this is a trivial example, we already know the derivative, du and write it down to later test our FFT wrapper.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"using SciMLOperators\nusing LinearAlgebra, FFTW\n\nL  = 2π\nn  = 256\ndx = L / n\nx  = range(start=-L/2, stop=L/2-dx, length=n) |> Array\n\nu  = @. sin(5x)cos(7x);\ndu = @. 5cos(5x)cos(7x) - 7sin(5x)sin(7x);\n","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"Now, we define the Fourier transform. Since our input is purely Real, we use the real Fast Fourier Transform. The funciton plan_rfft outputs a real fast fourier transform object that can be applied to inputs that are like x as follows: xhat = transform * x, and LinearAlgebra.mul!(xhat, transform, x).  We also get k, the frequency modes sampled by our finite grid, via the function rfftfreq.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"k  = rfftfreq(n, 2π*n/L) |> Array\nm  = length(k)\ntr = plan_rfft(x)","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"Now we are ready to define our wrapper for the FFT object. To FunctionOperator, we pass the in-place forward application of the transform, (du,u,p,t) -> mul!(du, transform, u), its inverse application, (du,u,p,t) -> ldiv!(du, transform, u), as well as input and output prototype vectors. We also set the flag isinplace to true to signal that we intend to use the operator in a non-allocating way, and pass in the element-type and size of the operator.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"T = FunctionOperator((du,u,p,t) -> mul!(du, transform, u), x, im*k;\n                     isinplace=true,\n                     T=ComplexF64,\n\n                     op_adjoint = (du,u,p,t) -> ldiv!(du, transform, u),\n                     op_inverse = (du,u,p,t) -> ldiv!(du, transform, u),\n                     op_adjoint_inverse = (du,u,p,t) -> ldiv!(du, transform, u),\n                    )","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"After wrapping the FFT with FunctionOperator, we are ready to compose it with other SciMLOperators. Below we form the derivative operator, and cache it via the function cache_operator that requires an input prototype. We can test our derivative operator both in-place, and out-of-place by comparing its output to the analytical derivative.","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"ik = im * DiagonalOperator(k)\nDx = T \\ ik * T\n\n@show ≈(Dx * u, du; atol=1e-8)\n@show ≈(mul!(copy(u), Dx, u), du; atol=1e-8)","category":"page"},{"location":"tutorials/fftw/","page":"FFT Tutorial","title":"FFT Tutorial","text":"≈(Dx * u, du; atol = 1.0e-8) = true\n≈(mul!(copy(u), Dx, u), du; atol = 1.0e-8) = true","category":"page"},{"location":"sciml/#Usage-with-SciML-and-beyond","page":"Usage with SciML and beyond","title":"Usage with SciML and beyond","text":"","category":"section"},{"location":"sciml/#Why-SciMLOperators?","page":"Usage with SciML and beyond","title":"Why SciMLOperators?","text":"","category":"section"},{"location":"sciml/","page":"Usage with SciML and beyond","title":"Usage with SciML and beyond","text":"Many functions, from linear solvers to differential equations, require the use of matrix-free operators in order to achieve maximum performance in many scenarios. SciMLOperators.jl defines the abstract interface for how operators in the SciML ecosystem are supposed to be defined. It gives the common set of functions and traits which solvers can rely on for properly performing their tasks. Along with that, SciMLOperators.jl provides definitions for the basic standard operators which are used in building blocks for most tasks, both simplifying the use of operators while also demonstrating to users how such operators can be built and used in practice.","category":"page"},{"location":"sciml/","page":"Usage with SciML and beyond","title":"Usage with SciML and beyond","text":"SciMLOperators.jl has the design that is required in order to be used in all scenarios of equation solvers. For example, Magnus integrators for differential equations require defining an operator u = A(t) u, while Munthe-Kaas methods require defining operators of the form u = A(u) u. Thus the operators need some form of time and state dependence which the solvers can update and query when they are non-constant (update_coefficients!). Additionally, the operators need the ability to act like \"normal\" functions for equation solvers. For example, if A(u,p,t) has the same operation as update_coefficients(A, u, p, t); A * u, then A can be used in any place where a differential equation definition f(u, p, t) is used without requring the user or solver to do any extra work. Thus while previous good efforts for matrix-free operators have existed in the Julia ecosystem, such as LinearMaps.jl, those operator interfaces lack these aspects in order to actually be fully seamless with downstream equation solvers. This necessitates the definition and use of an extended operator interface with all of these properties, hence the AbstractSciMLOperator interface.","category":"page"},{"location":"sciml/","page":"Usage with SciML and beyond","title":"Usage with SciML and beyond","text":"Some packages providing similar functionality are","category":"page"},{"location":"sciml/","page":"Usage with SciML and beyond","title":"Usage with SciML and beyond","text":"LinearMaps.jl\nDiffEqOperators.jl (deprecated)","category":"page"},{"location":"sciml/#Interoperability-and-extended-Julia-ecosystem","page":"Usage with SciML and beyond","title":"Interoperability and extended Julia ecosystem","text":"","category":"section"},{"location":"sciml/","page":"Usage with SciML and beyond","title":"Usage with SciML and beyond","text":"SciMLOperator.jl overloads the AbstractMatrix interface for AbstractSciMLOperators, allowing seamless compatibility with linear solves, and nonlinear solvers. Further, due to the update functionality, AbstractSciMLOperators can represent an ODEFunction in OrdinaryDiffEq.jl, and downstream packages. See tutorials for example of usage with OrdinaryDiffEq.jl, LinearSolve.jl, NonlinearSolve.jl.","category":"page"},{"location":"sciml/","page":"Usage with SciML and beyond","title":"Usage with SciML and beyond","text":"Further, the nonmutating update functionality allows gradient propogation through AbstractSciMLOperators, and is compatible with automatic-differentiation libraries like Zygote.jl. An example of Zygote.jl usage with Lux.jl is also provided in the tutorials.","category":"page"},{"location":"sciml/","page":"Usage with SciML and beyond","title":"Usage with SciML and beyond","text":"Please make an issue here if you come across an unexpected issue while using SciMLOperators.","category":"page"},{"location":"sciml/","page":"Usage with SciML and beyond","title":"Usage with SciML and beyond","text":"We provide below a list of packages that make use of SciMLOperators. If you are using SciMLOperators in your work, feel free to create a PR and add your package to this list.","category":"page"},{"location":"sciml/","page":"Usage with SciML and beyond","title":"Usage with SciML and beyond","text":"SciML.ai ecosystem: SciMLOperators is compatible with, and utilized by every SciML package.\nCalculustJL packages use SciMLOperators to define matrix-free vector-calculus operators for solving partial differential equations.\nCalculustCore.jl\nFourierSpaces.jl\nNodalPolynomialSpaces.jl\nSparseDiffTools.jl","category":"page"},{"location":"#SciMLOperators.jl:-Unified-operator-interface-for-SciML.ai-and-beyond","page":"Home","title":"SciMLOperators.jl: Unified operator interface for SciML.ai and beyond","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SciMLOperators is a package for managing linear, nonlinear, time-dependent, and parameter dependent operators acting on vectors, (or column-vectors of matrices). We provide wrappers for matrix-free operators, fast tensor-product evaluations, pre-cached mutating evaluations, as well as Zygote-compatible non-mutating evaluations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The lazily implemented operator algebra allows the user to update the operator state by passing in an update function that accepts arbirary parameter objects. Further, our operators behave like AbstractMatrix types thanks to  overloads defined for methods in Base, and LinearAlgebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Therefore, an AbstractSciMLOperator can be passed to LinearSolve.jl, or NonlinearSolve.jl as a linear/nonlinear operator, or to OrdinaryDiffEq.jl as an ODEFunction. Examples of usage within the SciML ecosystem are provided in the documentation.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SciMLOperators.jl is a registerd package and can be installed via","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\njulia> Pkg.add(\"SciMLOperators\")","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let M, D, F be matrix-based, diagonal-matrix-based, and function-based SciMLOperators respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"N = 4\nf = (u, p, t) -> u .* u\n\nM = MatrixOperator(rand(N, N))\nD = DiagonalOperator(rand(N))\nF = FunctionOperator(f, zeros(N), zeros(N))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the following codes just work.","category":"page"},{"location":"","page":"Home","title":"Home","text":"L1 = 2M + 3F + LinearAlgebra.I + rand(N, N)\nL2 = D * F * M'\nL3 = kron(M, D, F)\nL4 = M \\ D\nL5 = [M; D]' * [M F; F D] * [F; D]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each L# can be applied to AbstractVectors of appropriate sizes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = nothing # parameter struct\nt = 0.0     # time\n\nu = rand(N)\nv = L1(u, p, t) # == L1 * u\n\nu_kron = rand(N ^ 3)\nv_kron = L3(u_kron, p, t) # == L3 * u_kron","category":"page"},{"location":"","page":"Home","title":"Home","text":"For mutating operator evaluations, call cache_operator to generate in-place cache so the operation is nonallocating.","category":"page"},{"location":"","page":"Home","title":"Home","text":"α, β = rand(2)\n\n# allocate cache\nL2 = cache_operator(L2, u)\nL4 = cache_operator(L4, u)\n\n# allocation-free evaluation\nL2(v, u, p, t) # == mul!(v, L2, u)\nL4(v, u, p, t, α, β) # == mul!(v, L4, u, α, β)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The calling signature L(u, p, t), for out-of-place evaluations is equivalent to L * u, and the in-place evaluation L(v, u, p, t, args...) is equivalent to LinearAlgebra.mul!(v, L, u, args...), where the arguments p, t are passed to L to update its state. More details are provided in the operator update section below. While overloads to Base.* and LinearAlgebra.mul! are available, where a SciMLOperator behaves like an AbstractMatrix, we recommend sticking with the L(u, p, t), L(v, u, p, t), L(v, u, p, t, α, β) calling signatures as the latter internally update the operator state.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The (u, p, t) calling signature is standardized over the SciML ecosystem and is flexible enough to support use cases such as time-evolution in ODEs, as well as sensitivity computation with respect to the parameter object p.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Matrix-free operators with FunctionOperator\nFast tensor product evaluation with TensorProductOperator\nLazy algebra: addition, subtraction, multiplication, inverse, adjoint, transpose\nCouple fast methods for operator evaluation with inversion via InvertibleOperator\nOne-line API to update operator state depending on arbitrary parameters.\nMutating, nonmutating update behaviour (Zygote compatible)\nOne-line API to pre-caching operators for in-place operator evaluations","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nJuliaDiffEq on Gitter\nOn the Julia Discourse forums (look for the modelingtoolkit tag\nSee also SciML Community page","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(;mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also download the \n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">project</a> file.","category":"page"}]
}
